## 变量（variable）

它不是具体的值，只是一个用来存储具体值的容器或者代名词，因为它存储的值可以改变，所以称为变量

## 创建方式

基于 ES 语法规范，在 JS 中创建变量有以下方式

- var (ES3)
- function (ES3) 创建函数(函数名也是变量，只不过存储的值是函数类型的而已)
- let (ES6)
- const (ES6) 创建的是常量
- import (ES6) 基于 ES6 的模块规范导出需要的信息
- class (ES6) 基于 ES6 创建类

```javascript
/*
 * 语法：
 *   var [变量名]=值
 *   let [变量名]=值
 *   const [变量名]=值
 *   function 函数名(){
 *
 *   }
 *   ...
 */
var n = 13;
n = 15;
alert(n + 10);
//=>弹出来25 此时的n代表15

const m = 100;
m = 200;
//=>报错:Uncaught TypeError: Assignment to constant variable.
//不能给一个常量重新的赋值（常量存储的值不能被修改，能够修改就是变量了）
```

使用`var`可以同时申请多个变量,多个变量之间使用`,`隔开，结束使用`;`

```javascript
var a = 10,
  b = 20,
  c = 30,
  d = 40;
//=>虽然我们只写了一个var，但其实这是一个语法糖，
//=>我们所申请的每一个变量都是使用var申请的
```

【 **我们在编写程序的时候操作的都是存储在变量内的数据** 】

## 命名规范

- 严格区分大小写
- 遵循驼峰命名法：按照数字、字母、下划线或者\$来命名（数字不能做为名字的开头），
- 命名的时候基于英文单词拼接成一个完整的名字（第一个单词字母小写，其余每一个有意义单词的首字母都大写）
- 不能使用关键字和保留字：在 JS 中有特殊含义的叫做关键词，未来可能会成为关键字的叫做保留字

```javascript
var n=12;
var N=13;
//=>两个n不是同一个变量

var studentInfo / student_info / _studentInfo（下划线在前的，是公共变量） / $studentInfo（一般存储的是JQ元素）...

语义化强一些
  add / create / insert
  del（delete）/ update / remove（rm）
  info / detail
  log
  ...
```

---

## 变量提升

在作用域形成之后，js 代码自上而下执行之前，浏览器会把所有带`VAR`和`FUNCTION`的关键字提前，`VAR`会提前声明，但是不会赋值，`FUNCTION`会提前声明并定义。

【 **变量提升只会发生在当前作用域** 】

1. 全局变量提升:

   > 在全局作用域中申请的即为全局变量，全局变量只会提升到全局作用域(window)中，函数在提升的时候会创建一个新的堆内存用来存储自身的代码块，当执行代码的时候，声明提前过的代码浏览器不会再次执行。

```javascript
console.log(a); //=>undefined
//变量提升只会声明提升，
//只有当代码执行到赋值操作的时候才会赋值，相当于在页面顶端var a;
//因此我们在之前使用只能得到undefined
var a = 123;

test(); //=>123
//函数提升会将自身提升至页面最顶端，
//因此我们在函数声明之前也可以正常使用

function test() {
  console.log(123);
}
```

---

2. 局部变量提升:

   > 在函数内的使用`VAR`申请的变量称之为局部变量，只有在函数执行的时候才会触发提提升机制，但是只能提升到函数私有的作用域中，函数运行的时候会先给形参赋值，然后在进行变量提升，

**无法在全局中访问局部变量**

## 带 var 和不带的区别

1. 全局使用`VAR`声明

   > 在全局中使用`VAR`关键字申明一个变量时会自动和`window`形成一个映射的机制，可以直接使用`window.变量名`获取相应的值，因此当改变一个时另外一个也会改变，但是函数中使用`VAR`关键字声明的私有变量，并不会和`window`形成映射机制。

```javascript
var a = 123;
console.log(a); //=>123
console.log(window.a); //=>123
window.a = 321;
console.log(a); //=>321
console.log(window.a); //=>321
//由于映射机制的关系，改变其中一个另外一个也会改变
```

2. 全局未使用`VAR`声明

   > 如果在全局中未使用`VAR`关键字声明一个变量，则不会变量提升，不使用关键字声明而直接赋值的话就相当于给`window`添加一个属性，对象的机制是**即使没有这个属性，直接使用的话也不会报错，而是会显示 undefined**，因此在代码之前使用`window`访问的话得到的是`undefined`，但是不使用`window`而直接调用的话浏览器会报错

   ```javascript
   console.log(window.a); //=>undefined
   console.log(a); //=>报错  a is not defined
   a = 123;
   //不使用关键字var声明的变量并不会提升，因此我们在之前访问的话会直接报错，
   //但是访问window.a的话即使没有a也不会报错，只会返回undefiend
   ```

3. 函数内的`VAR`

   > 函数内使用`VAR`关键字声明的变量为私有变量，全局作用域中无法访问，同时变量提升遵循私有作用域的提升机制,如果函数内不使用`VAR`,其实就相当于给全局作用域中的变量再次赋值，使用的也是全局作用域中的变量，

```javascript
function test() {
  var a = 123;
}
console.log(a); //=>报错：a is not defined
console.log(window.a); //=>undefined
//在函数的变量是无法在全局内访问的，直接访问会直接报错，使用window是得到undefined
```

## if 判断的函数提升

1. 旧版本浏览器：

   > 在旧版本的浏览器中会直接进行函数提升，会忽略条件判断的结果

2. 新版本浏览器：

   > 在新版本浏览器中为了同时兼容 ES5 和 ES6 的规则作了一些处理，同样会忽略条件判断的结果，但是并不会声明定义同时提前，只会提前声明，赋值为`undefined`，只有条件成立时分数才会提前声明和定义

```javascript
f = function() {
  return true;
};
g = function() {
  return false;
};
(function() {
  //在新版本浏览器中会报错，因为立即执行函数形成的私有作用域内有
  //变量 g ，则不会去全局作用域中寻找，但是由于if判断语句的原因，只会进行声明提前，并不会赋值，使用()调用一个值为undefined的变量时系统会报错
  if (g() && [] == ![]) {
    //TypeError: g is not a function
    f = function() {
      return false;
    };

    function g() {
      return true;
    }
  }
})();
console.log(f());
console.log(g());
```

## 变量重名

1. 在 js 中全局作用域中申请的变量其实可以理解成是`window`的属性，由于对象的属性名是不可以重复的，所以如果变量名相同的话在变量提升阶段后面的会直接把前面所有重名的覆盖掉，代码执行阶段也是如此，重复的变量名并不会重新定义，只会重新赋值，从而把前面的值覆盖掉

2. 在下列代码中由于函数名和变量名字重复，在变量提升阶段使用`VAR`关键字申请的只会定义，默认值是`undefined`，并不会赋值，而后面的函数则会声明和定义一起提前，所以代码未执行带赋值代码之前，`test`都是函数，当执行到赋值代码的时候，此时`test`的值重新赋值为了`100`，当`100`调用函数时会报错

```javascript
test(); //4
function test() {
  console.log(1);
}
test(); //4
function test() {
  console.log(2);
}
test(); //4
var test = 100; //TypeError: test is not a function
test();
function test() {
  console.log(3);
}
test();
function test() {
  console.log(4);
}
```

## ES6 中变量提升

1. 在 ES6 中基于 let/const 等方式创建变量或者函数，不存在变量提升机制。因此在申明变量之前使用，会报错！而且还会切断和全局作用域`window`的映射机制。

2. 基于`LET`关键字申请的变量是不允许使用相同的变量名，即使不使用关键字申请变量，也会报错。

3. 在代码执行之前，浏览器会检测当前作用域所有申明的变量，并且记录其变量名，如果检测到基于`LET`关键字申请的变量存在重名的情况下，则会直接报错。不使用关键字申请变量时，浏览器在代码执行阶段，如果发现存在同样的命名时也会报错，

```javascript
//LET 关键字申请的变量不存在变量提升机制，所以在声明之前使用会直接报错
console.log(a); //ReferenceError: can't access lexical declaration `a' before initialization
let a = 10;

a = 20; //ReferenceError: can't access lexical declaration `a' before initialization
let a = 10;
console.log(a);

//在下面这行代码中，a和b都是基于LET关键字申请的当函数运行的时候，
//由于函数内部的a是使用LET申请的，所以不存在变量提升，所以在代码执行之前，
//浏览器就会报错ReferenceError: can't access lexical declaration `a'beforeinitialization
//假如注释掉函数内部中的第一行代码，对应的执行结果应该是20,20,10,20
let a = 10,
  b = 10;
let test = () => {
  console.log(a, b);
  let a = (b = 20);
  console.log(a, b);
};
test();
console.log(a, b);
```

## 暂时性死区

1. 在 ES6 语法规范中基于`LET`关键字关键字创建的变量在大部分的{}中都会形成一个块级作用域(类似于函数的私有作用域)，在块级作用域中基于`LET`创建的变量和全局作用域中的重名变量没有任何关系

```javascript
var a = 10;
if (true) {
  console.log(a); //会报错，但是报错的信息并不是变量命名冲突，而是语法错误，在a未申明之前无法访问，可以将使用 VAR 关键字创建的变量并不会影响当前这几行代码的错误信息
  let a = 20;
}
```

2.  直接使用 typeof 一个不存在的变量并不会报错。而是会返回`undefined`，但是在 ES6 中基于`LET`创建变量则改正了这一机制，在申明之前使用 typeof 检测类型是直接报错(ReferenceError: Cannot access 'c' before initialization);
