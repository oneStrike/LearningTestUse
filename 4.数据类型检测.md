#

## isNaN

[**isNaN**]用来检测是不是一个有效的合法数字，如果是一个有效的合法数字返回`false`，否则返回`true`。

```javascript
//=>语法：isNaN([value])
var num=12;
isNaN(num);
//->检测num变量存储的值是否为非有效数字 false

isNaN('13') =>false
isNaN('珠峰') =>true
isNaN(true) =>false
isNaN(false) =>false
isNaN(null) =>false
isNaN(undefined) =>true
isNaN({age:9}) =>true
isNaN([12,23]) =>true
isNaN([12]) =>false
isNaN(/^$/) =>true
isNaN(function(){}) =>true
```

【 **重要：isNaN 检测的机制** 】

```javascript
//=>首先验证当前要检测的值是否为数字类型的，如果不是，浏览器会默认的把值转换为数字类型
//=>把非数字类型的值转换为数字其它基本类型转换为数字：直接使用Number这个方法转换的

  [字符串转数字]
    Number('13')
    //=>13

    Number('13px')
    //=>NaN 如果当前字符串中出现任意一个非有效数字字符，结果则为NaN

    Number('13.5')
    //=>13.5 可以识别小数

  [布尔转数字]
    Number(true)
    //=>1
    Number(false)
    //=>0

  [其它]
    Number(null)
    //=>0
    Number(undefined)
    //=>NaN

  //=>把引用数据类型值转换为数字：先把引用值调取toString转换为字符串，
  //=>然后再把字符串调取Number转换为数字

   [对象]
     ({}).toString()
     //=>'[object Object]' ->NaN

   [数组]
     [12,23].toString()
     //=>'12,23' ->NaN
     [12].toString()
     //=>'12' ->12

   [正则]
     /^$/.toString() ->'/^$/'
     //=>NaN

  Number('')
  //=>0
  [].toString()
  //=>''
  isNaN([])：
  //=>false

//=>当前检测的值已经是数字类型，是有效数字返回false，不是返回true
//=>数字类型中只有NaN不是有效数字，其余都是有效数字

```

## **typeof**

`typeof`用来检测一个数据的类型（是一个一元运算符，无法细分的检测数据）

```javascript
//=>语法：typeof [value] =>检测value的数据类型
//=>返回值：使用typeof检测出的结果是一个字符串，字符串中包含着对应的数据类型，
//=>例如"number"/"string"/"boolean"/"undefined"/"object"/"function/symbol"

typeof null =>"object"
//=>因为null代表空对象指针（没有指向任何的内存空间）

//=>typeof检测数组/正则/对象，最后返回的都是"object"，
//=>也就是基于这种方式无法细分对象

面试题：
console.log(typeof []);
//=>"object"

console.log(typeof typeof []);
//=>typeof "object"
//=>"string"
```

直接使用 typeof 一个不存在的变量并不会报错。而是会返回`undefined`，但是在 ES6 中基于`LET`创建变量则改正了这一机制，在申明之前使用 typeof 检测类型是直接报错(ReferenceError: Cannot access 'c' before initialization);

## in

`in`主要用于检测一个属性自身或这原型链中是否存在，如果存在则返回`true`,否则返回`false`。`in`需要两个参数，第一个是指定的变量，可以是数组，也可以是一个对象。第二个是指迭代的对象。在检测一个实例的时候直接书写的需要检测的属性（字符串格式）。

**如果使用`for/in`语句来检测一个属性时，那么这个属性必须是`Enumerable` （可枚举）属性**

检测数组

```javascript
var arr = [10, 20, 30, 40, 50];
for (var x in arr) {
  console.log(arr[x]); //=>10,20,30,40,50
  //这样我们可以直接输出数组的每一项的值

  console.log(x); //=>0,1,2,3,4
  //直接输出x的话输出的就是数组的索引（下标）
}
```

**不推荐`for/in`语句遍历数组**

- 在 js 中我们有很多中遍历数组的方法，使用`for/in`遍历数组时得到的结果有时可能并不是我们所需要的，当我们使用`for/in`进行遍历数组时，如果我们在原型中添加了一些属性或者方法的话，那么他们也会被遍历出来，而且`for/in`得到的结果也是字符串形式的，有时候我们做一些运算的时候处理起来也会比较麻烦！`for/in`的查找机制是**无序查找**，所有在某些情况下我们得到的顺序可能会出现混乱，
- js 中遍历数组我们可以使用普通的`for`循环，还可以使用`forEach()`方法，在 ES6 中我们还可以使用`for of`来遍历数组

检测对象

```javascript
//创建一个构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}
var person = new Person("平野绫", 18);

console.log(person.name); //=>'平野绫'
//我们可以使用in 来检测一个实例中是否拥有这个属性
//语法 ： '属性'  in  实例   属性必须书写为字符串格式
console.log("name" in person); //=>true
//person中有name这个属性，所以返回的true
//但是 in 还有一个特点 ： 如果一个实例没有这个属性，但是实例的原型拥有这个属性的话，
//他也会返回true
console.log("toString" in person); //=>true
//我们创建的实例中并没有toString这个属性，但是实例的原形链中拥有这个属性
//in 会查找实例的原型，而且是无序查找，只有当原型中没有时才会返回false

//我们也可以使用 in 运算符来遍历我们的实例
for (var key in person) {
  //我们只希望得到自身的属性，那么我们可以使用hasOwnProperty
  if (person.hasOwnProperty("key")) {
    console.log(key);

    //console.log(person[key])

    //=>上面一行代码可以使我们获得每个属性的属性值，
    //注意此处不要加引号，否则会得到undefined
    //如果是加引号的话浏览器会认为是输出当前实例的某一个属性
    //如果不加引号，那么[]中的就是一个变量，浏览器会计算出结果后输出
  }
}
```

> - instanceof
>
> - constructor
>
> - Object.prototype.toString.call()
