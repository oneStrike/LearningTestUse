#

## 解构赋值

按照一个数据值的结构，快速获取解析其中的内容

语法:let 赋值 = 结构

左右两边的数据结构需要是一致的，如果是数组的话需要两边都以数组的结构出现。`let [] = 数组`。对象也是同理

**数组解构赋值**

```javascript
let arr = [10, 20, 50];

let [a, b, c] = arr;
//=>这中写法等价于
let a = arr[0],
  b = arr[1],
  c = arr[2];

let [a, ...b] = arr;
console.log(a);
//=>10
console.log(b);
//=>[20,30]
//=>...b表示的是除了前面接收的以外，其他的剩余项全部赋值给b

let [a, , b] = arr;
//=>中间使用空格表示不接收赋值
```

如果左边用于赋值的变量多余右边，那么就会赋值`undefined`,我们也可以直接将其设置一个默认值

```javascript
let arr = [10, 20, 30];
let [a, b, c, d = 0] = arr;
//=>如果d没有接收到来自右边的赋值。那么就将其赋值为0
//=>如有值供其接收，就会赋值为接收到的值，
//=>我们手动设置的只会在没有值接收的情况下才会生效
```

解构赋值可以使我们更加方便快捷的操作数据，如使 a 和 b 两个变量的值交换位置

```javascript
var a = 10;
var b = 20;

//=>非解构赋值可以使用第三个变量作为交换容器使用
var c = a;
a = b;
b = c;

//=>如果使数字的话我们还可以使用相加交换
a = a + b;
b = a - b;
a = a - b;

//=>结构赋值
[b, a] = [a, b];
//=>将a和b两个变量放入一个数组中，
//=>然后使用结构赋值依次交换，更加的简单快捷
```

**对象解构赋值**

对象的结构赋值和数组的语法是一样的，只不过我们在左边用于赋值的变量须和右边对象的属性名一致才可以，如果需要不同的名字，可以额外设置

```javascript
let obj = { name: "绫", age: 20, sex: "女" };
let { name, age, sex } = obj;
cosnole.log(name, age, sex);
//=>'绫',18，'女'
//=>结构赋值操作完成之后，我们用于接收的变量和对象的属性就没有任何关系了

obj.name = "钉宫";
cosnole.log(name);
//=>'绫'
console.log(obj.name);
//=>'钉宫'

//=>它们连个任意一个改变都和另外一个没有任何关系
```

我们有时为了防止对象的属性名和全局的变量名冲突，我们还可以自定义用于接收的变量名

```javascript
let obj = { name: "绫", age: 20, sex: "女" };
let { name: nameAA, age: ageAA, sex: sexAA } = obj;
//=>我们可以直接使用  对象属性名:自定义变量名  来自定义用于接收的变量名

//=>同样的，为了防止接收的变量多于对象的属性时多出的变量被默认赋值为undefined，我们也可以设置默认的属性

let { name, age, sex, gender = 0 } = obj;
console.log(gender);
//=>0 因为对象内没有供gender接收的数据，所以会被设置为我们默认设置的数据
```

**小应用**

```javascript
let value = { name: "xxx", age: 25, score: [12, 23, 34, 45] };
//=>我们需要的形式 a=name,b=score[0],c=score[0]以外的所有的值

let {
  name: a,
  score: [b, ...c]
} = value;
//=>因为obj是对象类型。所以我们左边用于接收的也应该是一个对象数据类型
//=>name:a，表示的是将value内的name属性值重新赋值给我们的自定义变量a
//=>score:[a,...b]:表示将value内的score中的数据重新赋值给我们的一个自定义变量
//=>而我们的自定义变量同样也是解构赋值形式的，
//=>b：表示将第获取score中的第一个值
//=>...c:表示获取b以外的所有值
```
