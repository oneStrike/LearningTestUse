# 正则表达式 （Regular Expression）

## 简介

- 正则表达式（regexp）是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式
- 用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。

## 创建方式

**构造函数方式**

一般在我们不清楚这个正则的规则时使用的方法

```javascript
let reg = new RegExp("\\d", "g");
/**
 * 当我们不清楚某些正则规则是可以使用这种写法
 * 构造函数创建的不需要加//，可以直接数书写，【,】后面书写修饰符
 * 使用特殊元字符时要进行转移，【\】
 * 等价于   ==>/\d/g
 */

//=>创建时可以接收一个变量
let re = /\b+/g;
let reg = new RegExp(re);
```

**字面量方式**

如果这个规则是不变的，那么我们使用字面量的方法会，对性能相对友好一些

```javascript
let reg = /\b+/g;
//=>只书写两个//的话是注释
```

字面量方式创建的正则使用`//`包裹起来是元字符，`//`后面的是修饰符

## 字符类型（Character Classes）

### 修饰符

1. `g` 是否开启全局搜索
2. `i` 是否忽略大小写
3. `m` 是否开启多行搜索
4. `u` 使用 unicode 码的模式进行匹配
5. `y` 执行“粘性”搜索,匹配从目标字符串的当前位置开始

### 普通字符

1. `.` 匹配换行符之外的任一字符
2. `\d` 匹配 0~9 之间的任意数字 ==>[0-9]
3. `\D` 匹配非 0~9 之间的任意数字 ==>[^0-9]
4. `\w` 匹配数字，大小写字母，下划线 ==>[0-9a-zA-Z_]
5. `\W` 匹配非数字，大小写字母，下划线 ==>[^0-9a-za-z_]
6. `\s` 匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。
7. `\S` 匹配一个非空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。

### 字符集（Character Sets）

1. `[xyz]` 匹配出现的 x,y,z 之间的任一一个字符
2. `[^xyz]` 匹配出现的 x,y,z 之外的任意一个字符

**细节**

1. `[]`中出现的大部分字符都是字面意思，`.`仅仅代表的是一个`.`，不再具有特殊含义

```javascript
let reg=/[.]/g;

let.test('.')
//=>true
reg.test('+')
//=>false
reg.test('1')
//=>false
reg.test('s')
//=>false
let.test(.)
//=>报错：SyntaxError: expected expression, got '.'  ==> 语法错误
```

2. `\d`拥有这种特殊含义的并不会解析成字面意思，仍具有特殊的含义

```javascript
let reg = /[\d]/g;

reg.test(1);
//=>true
reg.test(23);
//=>true
reg.test(132132);
//=>true
reg.test("d");
//=>false
//=>\d 仍具有特殊的含义
```

3. `[]`中出现的字符都是单项字符，每个字符之间并没有关联性

```javascript
let reg = /[12-89]/g;

reg.test(1);
//=>true
reg.test(12);
//=>true
reg.test(98);
//=>true
reg.test(34);
//=>true
reg.test(26);
//=>true
reg.test(0123);
//=>false

/**
 * 上面的规则是三个部分
 * 1
 * 2-8
 * 9
 * 1或者2-8之间的任一数字再或者是9
 * 并不会解析成12到89之间的数字
 * 连字符 - 只会连接左右两边的第一个字符
 */
```

### 边界（Boundaries）

1. `^` 以某个字符开始
2. `$` 以某个字符结束
3. `\b` 单词边界
4. `\B` 非单词边界

### 分组（grouping）与反向引用（back references）

1. `(x)` 分组并捕获
2. `\n` 反向引用
3. `(?:x)` 只分组不捕获

**细节**

1. 默认情况下使用`()`匹配到的内容都会被捕获到，如果我们不需要捕获的内容可以使用`(?:)`，它代表只进行分组，并不进行捕获，**因为捕获对性能并不友好**

```javascript
//=>匹配并捕获一个身份证相关的信息
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d{1})(\d|X)$/;
//=>返回的是一个数组，里面包含这我们捕获的所有信息

//=>如果我们只希望获取关键的信息可以使用下面的规则
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d){\d|X}$/;
//=> ()内使用[?:]表示只进行分组，并不进行捕获
```

![uuHGK1.png](https://s2.ax1x.com/2019/09/27/uuHGK1.png)

2. `()`中的正则表达式被称为子表达式，是整个正则规则下的一个子规则，可以反向引用

```javascript
let reg = /(\w)(\d)\2\1/g;

reg.test("p88p");
//=>true
reg.test(1221);
//=>true
reg.test("p8p8");
//=>true
reg.test(1212);
//=>fasle

/**
 * \2对应的是(\d)规则
 * \1对应的是(\w)规则
 * \后面跟随的是一个整数，它必须有一个相对应的()子表达式
 * \n必须和()内出现的规则完全匹配
 *
 *我们可以理解成每一个\n都是将它对应的子表达式重新书写一遍
 */
```

### 数量词（Quantifiers）

1. `*` 匹配 0 次或 多次
2. `+` 匹配 1 次或 多次
3. `?` 匹配 0 次或 1 次
4. `x|y` 匹配 x 或者 y
5. `{n}` 匹配 n 次
6. `{n,}` 匹配 n 次或 n 以上的次数
7. `{n,m}` 匹配 n 到 m 次

### 断言（Assertions）

也叫做**正向预查**和**负向预查**。

1. `x(?=y)` 匹配 x 的下一项必须是 y
2. `x(?!y)` 匹配 x 的下一项不能是 y

## 捕获模式

`()`不单单具有分组的功能，同时也具有捕获组的功能，使用`()`默认就会开启捕获模式在基于正则的`exec`和`String`的`match`返回的数组中，被`()`内的规则匹配的字符被单独的剥离出来

放在数组中，多个捕获组会依次存放在数组中。可以在`()`中使用`?:`来告知浏览器只分组，不进行捕获

```javascript
//=>匹配并捕获一个身份证相关的信息
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d{1})(\d|X)$/;
let str = "130828199012040617";
reg.exec(str);
//=>返回的是一个数组，里面包含着我们捕获的所有信息
//=>["130828199012040617","130828","1990","12","04","06","1","7"]
//=>索引0的位置上存放的是匹配整个正则规则的文本
//=>捕获组捕获的字符会依次添加进数组的索引中

//=>如果我们只希望获取关键的信息可以使用下面的规则
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d){?:\d|X}$/;
//=> ()内使用[?:]表示只进行分组，并不进行捕获
//=>["130828199012040617","130828","1990","12","04","1"]
//=>所有不进行捕获的分组都不会添加进数组中。
```

## 贪婪模式

正则在默认情况下会尽可能多的匹配到符合规则的字符，我们把这中叫做**贪婪模式**。

在量词元字符的后加`?`则可以取消贪婪模式

```javascript
let reg = /\d+/g;
//=>匹配1或者多个数字
let str = "123abc456bcd";
reg.exec(str);
//=>123

/**
 * 1符合我们的规则，12也符合，同样123也符合规则，因为贪婪模式的存在，
 * 使得我们默认情况下会尽可能多的获取到符合规则的字符串
 * 在量词后面使用 ?  来取消贪婪模式
 */

let reg = /\d+?/;
//=>匹配1到多个数字，添加?表示取消贪婪模式
let str = "123abc456bcd";
reg.exec(str);
//=>1   ==>非贪婪模式下只会匹配第一个符合规则的字符
```

## 懒惰模式

在一个目标字符串中如果有多处符合正则规则的字符，默认情况下只会匹配一处，并不会将所有符合规则的字符匹配

这种就叫**懒惰模式**。可以使用全局匹配`g`来取消懒惰模式

```javascript
let reg = /\d+/;
let str = "123abc456bcd";

reg.exec(str);
//=>123;
/**
 * 这个规则永远只会返回123，因为正则现在是贪婪模式
 * 每一次的匹配都会从目标字符串起始位置开始匹配
 */
```

**非懒惰模式**

```javascript
let reg = /\d+/g;
let str = "123abc456bcd";

reg.exec(str);
//=>123;
reg.exec(str);
//=>456
reg.exec(str);
//=>null
reg.exec(str);
//=>123
reg.exec(str);
//=>456
reg.exec(str);
//=>null

/**
 * 取消贪婪模式后，虽然仍然只会匹配第一处符合规则的字符
 * 但是如果后面继续匹配则会从上一次匹配的地方开始匹配，并不是从目标字符串的起始位置开始
 * 之所以会出现一次null是因为非贪婪模式下，会记录每次匹配的位置，然后下次匹配从当前位置开始
 * 如果后面没有符合规则的字符就会返回null
 *
 * 例如：123abc456bcd
 * 第一次匹配123，第二次从3后面的第一个字符开始匹配，可以匹配到456，
 * 第三次从6后面的第一个字符开始匹配，但是6后面并没有符合规则的字符，所以返回null
 */
```

**如果希望匹配到所有的符合项，可以使用`String`中的实例方法`match`来获取**

## **RegExp 属性和方法**

**test**

用来检测一个目标字符串是否满足当前正则对象的规则，返回`true`或者`false`。会改`lastIndex`的值

**exec**

也是用来检索一个目标字符串是否满足当前正则对象的规则，

不过在匹配成功时`exec`返回的是一个数组，失败会返回`null`

```javascript
let reg = /(\d+)(a)(b)/g;
let str = "123abc456bcd";

reg.exec(str);
//=>["123ab","123","a","b"]

/**
 * 索引0的位置上存储的是所有符合规则的文本
 * 而其他的索引上存放的是捕获组捕获到的内容
 */
```

返回的数组中拥有一个`input`属性，它表示目标字符串，还拥有一个`index`属性，表示的是第一个匹配到的字符的索引

**lastIndex**

- 表示的是正则下一次匹配的起始位置，只有当正则开启了全局匹配模式才会生效。

- 他会和当前的正则对象绑定，只要是当前正则对象检索的目标字符串这个属性都会关联

- 如果不开启全局匹配`g`，正则每次匹配都会从目标字符串索引`0`的位置上开始匹配。

- 同一个正则对象匹配不同的目标字符串并不会重置`lastIndex`的值。因为它是和正则对象绑定在一起的。

```javascript
let reg = /\d+/g;
let str = "123abc456bcd";
let str2 = "789xyz654asd";

reg.exec(str);
//=>123
reg.exec(str2);
//=>654

/**
 * 通常来讲匹配两个不同的目标字符串时lastIndex的值应该会重置，
 * 并且每个目标字符串应该对应自己的lastIndex，但是结果并不是
 * 由此可以看出lastIndex是和正则对象绑定在一起
 * 和需要匹配的目标字符串并没有关联。只要是同一个正则对象，
 * 那么它每次检索都会使用同一个lastIndex的值
 */
```

`test()`方法也会改变`lastIndex`的值

```javascript
let reg = /\d+/g;
let str = "123abc456bcd";
if (reg.test(str)) {
  console.log(reg.exec(str));
  //=>456
}
/**
 * 上面的代码表示如果str字符串内有匹配项就输出每一个匹配项
 * 但是test()方法同样会改变lastIndex的值，
 * 因此我们并不能完全获取到目标字符串中所有的匹配项
 */
```

当`lastIndex`的值大于目标字符串的`length`时，`lastIndex`会被重置，从`0`开始重新匹配。

```javascript
let reg = /|d+/g;
let str = "123abc456bcd";
reg.exec(str);
//=>123
reg.exec(str);
//=>456
reg.exec(str);
//=>null
reg.exec(str);
//=>123
reg.exec(str);
//=>456;

/**
 * 全局匹配下每一次匹配lastIndex都会记录下次匹配起始位置的索引
 * 再一次匹配的位置由lastIndex的值决定
 *
 * 123abc456bcd
 * 第一次匹配123，此时lastIndex存储的值是3后面第一个字符的索引
 * 再次匹配也会从这个索引位置开始
 * 第二次匹配的是456，此时lastIndex存储的是6后面第一个字符的索引
 * 第三次匹配时6后面所有的字符都没有符合规则的了
 * 那么就会返回null，同时lastIndex重置，
 * 再次匹配的话会从目标字符串的起始位置开始
 */
```

**`lastIndex`**是一个可读写的属性，但是我们修改它的值并不会对匹配顺序和匹配结果造成影响！
