# 正则表达式 （Regular Expression）

## 简介

- 正则表达式（regexp）是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式
- 用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。

## 创建方式

**构造函数方式**

一般在我们不清楚这个正则的规则时使用的方法

```javascript
let reg=new REgExp('/\d/','g');
//当我们不清楚这个规则具体是什么，或者这个规则是由用户创建的，一般使用构造函数的方式创建
//=>使用字符串格式书写规则【,】 后面书写修饰符

//=>创建时可以接收一个变量
let re=/\b+/g;
let reg=new RegExp(re);
```

**字面量方式**

如果这个规则是不变的，那么我们使用字面量的方法会减少性能的消耗

```javascript
let reg=/\b+/g;
//=>只书写两个//的话是注释
```

## 字符规则

字面量方式创建的正则使用`//`包裹起来是元字符，`//`后面的是修饰符

### 修饰符

1. `g`  是否开启全局搜索
2. `i`	是否忽略大小写
3. `m`  是否开启多行搜索
4. `u`	使用unicode码的模式进行匹配
5. `y`	执行“粘性”搜索,匹配从目标字符串的当前位置开始
6. `s`	允许 . 匹配换行符

### 元字符&修饰符

**特殊元字符**

1. `\`		 转义字符
2. `^` 		 以某个字符开始
3. `$` 		 以某个字符结束
4. `.` 		 换行符之外任意字符
5. `x|y` 	 匹配x或者y 
6. `()` 	 表达式分组
7. `(?:)`    当前分组只匹配不捕获
8. `(?=)` 	 正向预查
9. `(?!)` 	 反向预查
10. `[xyz]`  匹配x,y,z中的任意字符
11. `[^xyz]` 匹配x,y,z以外的任意字符
12. `\b` 	 单词边界(一个单词的左边或者右边不被任何一个字符所占用)
13. `\B`	 匹配非的单词边界	 
14. `\d`	 匹配0-9任意数字  ==>[0-9]
15. `\D`     匹配非0-9数字外的任意字符  ==>[^0-9]
16. `\s`	 匹配任意一个空白字符（包括\t制表符[TAB键四个空格]）
17. `\S` 	 匹配一个非空白字符
18. `\w`	 匹配任意字母,数字,下划线  ==>[A-Za-z0-9]
19. `\W`	 匹配任意字母,数字,下划线  ==>[^A-Za-z0-9]

- `^`在`[]`开头使用表示取反的意思，

**量词元字符**

1. `*` 匹配前一个表达式出现0次或者多次 ==>{0,}
2. `+` 匹配前一个表达式出现1次或者多次 ==>{1,}
3. `?` 匹配前一个表达式出现0次或者1此 ==>{0,1}
4. `{n}` 匹配前一个表达式出现n次
5. `{n,}` 匹配前一个表达式出现n次或者多次
6. `{n,m}` 匹配一个表达式出现n到m次

- `?`在不同的地方有着不同的规则，如果在量词元字符后面使用，表示的是否开启**贪婪模式**（匹配尽量少的字符）

**普通元字符**

- 基于字面量方式创建的正则，除了量词元字符和特殊元字符外都是普通元字符

### 细节

**`[]`**

1. `[]`中的字符大部分情况是都是单一的字符，没有关联性,特殊元字符除外

```javascript
let reg=/^[12-98]$/;
reg.test('12')
//=>false
reg.test('98')
//=>false
reg.test('7')
//=>true
reg.test('8')
//=>true

/*
 *它并不是表示12-98之间的数字
 *因为在[]中所出现的字符都是一个单一的字符
 *它表示的是匹配1或者2-9或者8
 */

let reg=/^[\d]$/;
reg.test('1');
//=>true
reg.test(9)
//=>true
reg.test(12);
//=>false   只匹配一位，因为没有加量词

let reg=/^[\d]+$/;
reg.test(123);
//=>true

//=>. 在[] 并没有特殊的函数，代表的是它自己本身
let reg=/^[.]$/;
reg.test('.')
//=>true
//=>在 [] 中不再具有特殊含义
```

**练习题**

```javascript
//=>匹配年龄  18-65
let reg=/^([1][8-9])|([2-5]\d)|([6][0-5])$/

/**
 * 将年龄拆为三部分  18-19  20-59   60-65
 * 分别书写这三个部分的规则，然后在拼接在一起
 */

//=>匹配字符  [object 任意字符]

let reg = /^\[object .+\]$/;

//=>如果要匹配[]应使用转义符\，否则会被解析成元字符

```


## 正则中的方法

**test**

用来验证一个字符串是否满足和正则相匹配，返回`true`或者`fale`

```javascript
let reg = /^[0-9]$/;
reg.test('0')
//=>true

```