# 正则表达式 （Regular Expression）

## 简介

- 正则表达式（regexp）是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式
- 用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。

## 创建方式

**构造函数方式**

一般在我们不清楚这个正则的规则时使用的方法

```javascript
let reg = new RegExp("\\d", "g");
/**
 * 当我们不清楚某些正则规则是可以使用这种写法
 * 构造函数创建的不需要加//，可以直接数书写，【,】后面书写修饰符
 * 使用特殊元字符时要进行转移，【\】
 * 等价于   ==>/\d/g
 */

//=>创建时可以接收一个变量
let re = /\b+/g;
let reg = new RegExp(re);
```

**字面量方式**

如果这个规则是不变的，那么我们使用字面量的方法会，对性能相对友好一些

```javascript
let reg = /\b+/g;
//=>只书写两个//的话是注释
```

字面量方式创建的正则使用`//`包裹起来是元字符，`//`后面的是修饰符

## 字符类型（Character Classes）

### 修饰符

1. `g` 是否开启全局搜索
2. `i` 是否忽略大小写
3. `m` 是否开启多行搜索
4. `u` 使用 unicode 码的模式进行匹配
5. `y` 执行“粘性”搜索,匹配从目标字符串的当前位置开始

### 普通字符

1. `.` 匹配换行符之外的任一字符
2. `\d` 匹配 0~9 之间的任意数字 ==>[0-9]
3. `\D` 匹配非 0~9 之间的任意数字 ==>[^0-9]
4. `\w` 匹配数字，大小写字母，下划线 ==>[0-9a-zA-Z_]
5. `\W` 匹配非数字，大小写字母，下划线 ==>[^0-9a-za-z_]
6. `\s` 匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。
7. `\S` 匹配一个非空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。

### 字符集（Character Sets）

1. `[xyz]` 匹配出现的 x,y,z 之间的任一一个字符
2. `[^xyz]` 匹配出现的 x,y,z 之外的任意一个字符

**细节**

1. `[]`中出现的大部分字符都是字面意思，`.`仅仅代表的是一个`.`，不再具有特殊含义

```javascript
let reg=/[.]/g;

let.test('.')
//=>true
reg.test('+')
//=>false
reg.test('1')
//=>false
reg.test('s')
//=>false
let.test(.)
//=>报错：SyntaxError: expected expression, got '.'  ==> 语法错误
```

2. `\d`拥有这种特殊含义的并不会解析成字面意思，仍具有特殊的含义

```javascript
let reg = /[\d]/g;

reg.test(1);
//=>true
reg.test(23);
//=>true
reg.test(132132);
//=>true
reg.test("d");
//=>false
//=>\d 仍具有特殊的含义
```

3. `[]`中出现的字符都是单项字符，每个字符之间并没有关联性

```javascript
let reg = /[12-89]/g;

reg.test(1);
//=>true
reg.test(12);
//=>true
reg.test(98);
//=>true
reg.test(34);
//=>true
reg.test(26);
//=>true
reg.test(0123);
//=>false

/**
 * 上面的规则是三个部分
 * 1
 * 2-8
 * 9
 * 1或者2-8之间的任一数字再或者是9
 * 并不会解析成12到89之间的数字
 * 连字符 - 只会连接左右两边的第一个字符
 */
```

### 边界（Boundaries）

1. `^` 以某个字符开始
2. `$` 以某个字符结束
3. `\b` 单词边界
4. `\B` 非单词边界

### 分组（grouping）与反向引用（back references）

1. `(x)` 分组并捕获
2. `\n` 反向引用
3. `(?:x)` 只分组不捕获

**细节**

1. 默认情况下使用`()`匹配到的内容都会被捕获到，如果我们不需要捕获的内容可以使用`(?:)`，它代表只进行分组，并不进行捕获，**因为捕获对性能并不友好**

```javascript
//=>匹配并捕获一个身份证相关的信息
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d{1})(\d|X)$/;
//=>返回的是一个数组，里面包含这我们捕获的所有信息

//=>如果我们只希望获取关键的信息可以使用下面的规则
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d){\d|X}$/;
//=> ()内使用[?:]表示只进行分组，并不进行捕获
```

![uuHGK1.png](https://s2.ax1x.com/2019/09/27/uuHGK1.png)

2. `()`中的正则表达式被称为子表达式，是整个正则规则下的一个子规则，可以反向引用

```javascript
let reg = /(\w)(\d)\2\1/g;

reg.test("p88p");
//=>true
reg.test(1221);
//=>true
reg.test("p8p8");
//=>true
reg.test(1212);
//=>fasle

/**
 * \2对应的是(\d)规则
 * \1对应的是(\w)规则
 * \后面跟随的是一个整数，它必须有一个相对应的()子表达式
 * \n必须和()内出现的规则完全匹配
 *
 *我们可以理解成每一个\n都是将它对应的子表达式重新书写一遍
 */
```

### 数量词（Quantifiers）

1. `*` 匹配 0 次或 多次
2. `+` 匹配 1 次或 多次
3. `?` 匹配 0 次或 1 次
4. `x|y` 匹配 x 或者 y
5. `{n}` 匹配 n 次
6. `{n,}` 匹配 n 次或 n 以上的次数
7. `{n,m}` 匹配 n 到 m 次

### 断言（Assertions）

1. `x(?=y)` 匹配 x 的下一项必须是 y
2. `x(?!y)` 匹配 x 的下一项不能是 y

## 捕获模式

## 贪婪模式

## 懒惰模式

## **RegExp 方法**

**test**

**exec**
