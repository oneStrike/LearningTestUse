## 严格模式

在 ES5 中使用严格模式需要在当前作用域内的第一行书写`use strict`;如果书写在全局作用域内的第一行则表示当前的整个文件使用的都是严格模式。

> 全局作用域的严格模式只会影响当前的文件，并不会影响到其他的 js 文件，

> 在实际多人开发的项目中，当我们完整开发之后会将所有人开发的代码合并压缩在一个 js 文件内，当我们想要在自己开发的 js 代码使用严格模式的话应该使用一个立即执行函数，将自己所有的代码放在一个单独的作用域内，这样就不会影响到其他人所书写的代码，因为`uer strict`只对当前的作用域有效果

## 严格模式和非严格模式的区别

- 我们应当在开发中尽可能的使用严格模式来书写代码，因为在严格模式中对语法的要求更加的严谨，更加的符合规范

### arguments

在严格模式中`arguments`的`arguments.callee`和`arguments.callee.caller`无法使用，同时`arguments`不再和形参形成映射机制，

```javascript
function test() {
  "use strict";
  console.log(argument.callee);
}
test(); //=>报错：TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
//这两个方法是无法在严格模式中使用的，使用的话浏览器会直接报错

function test(x, y) {
  console.log(arguments[0]); //=>10
  x = 100;
  console.log(arguments[0]); //=>100
}
test(10, 20);
//在非严格模式中arguments依旧和形参存在着映射关系，当一个改变时，另一个也会跟着改变

function test(x, y) {
  "use strict";
  console.log(arguments[0]); //=>10
  x = 100;
  console.log(arguments[0]); //=>100
  arguments[0] = 200;
  console.log(x);
}
test(10, 20);
//在严格模式中arguments和形参不存在映射关系，改变这两个的属性时另一个并不会改变
//也就是说在严格模式中arguments只作为实参集合体，并不能做出改变
```

---

### this

在非严格模式中`this`不能明确它的指向，那么它就会指向`window`,但时在严格模式中如果不明确`this`的指向，那么他就会指向`undefined`

```javascript
function test() {
  console.log(this); //=>window
}
test();
//=>在非严格模式中不指定this的指向，thsi就会自动指向window

function test() {
  "use strict";
  console.log(this); //=>undefined
}
test();
//在严格模式中this的指向不明确的话就会指向undefined，代表没有执行主体
```

### 对象重名

在非严格模式中对象的属性名如果重复的话只会由后面的覆盖前面的，但是在严格模中后面重复属性名设置的并不会生效，只有第一个才会生效

```javascript
function test() {
  var obj = { n: 2, n: 4 };
}
test();
console.log(obj.n); //=>4
//非严格模式中重名的属性名会由后面的覆盖掉前面的

function test() {
  "use strict";
  var obj = { n: 4, n: 8 };
}
test();
console.log(obj.n); //=>4;
//在严格模式中重名的属性名只有第一个设置的会生效，其他的都不会生效
```
