#

## 闭包

闭包是一种现象，在代码执行的时候产生一个不销毁的私有作用域（栈内存）就叫做闭包，闭包可以保护其内部的变量不受外部污染，还可以保存内部的值，方便我们以后调用，

- 过多的使用闭包会造成性能上的缺失，因为会造成过多的栈内存无法被释放，因此我们在开发中应该尽量避免使用闭包。

- 过多的使用全局变量会造成**全局变量污染**，因此有时候我们可以将一些功能封装在闭包当中，使其变成私有变量，减少全局变量的污染。

- 其实在下面这张图中我们也使用了闭包，因为函数 B 的始终指向函数 A 的作用域，因此函数 A 的作用域无法被销毁，其中的数据也会被保存起来，
  > ![nyuF58.png](https://s2.ax1x.com/2019/09/14/nyuF58.png)

## 闭包小应用

```javascript
//假如我们的页面中有若干个li，我们需要给每一个li绑定点击事件
//点击的时候显示出每个li的文本

//获取li的集合（类数组）
var li = document.getelementsByTagName("li");
//循环li类数组获取到每一个li
for (var i = 0; i < li.length; i++) {
  //使用闭包个每个li绑定点击事件
  li[i].onclick = (function(j) {
    return function() {
      console.log(li[j].innerHTML);
    };
  })(i);
}
//执行一个立即执行函数我们都把当前的i通过传参的形式传递给立即执行函数，
//而我们又在立即执行函数内返回一个新函数的堆内存地址，由于每执行一次
//立即执行函数都会产生一个不同的作用域， 所以我们传递的i会以固定值的形式保在返回函数体的堆内存中。
//当循环结束的时候，循环了几次就创建了几个堆内存，而每个堆内存中的接收的i的值也不一样
//每个li所绑定的堆内存地址也不一样，但是这样会影响性能，不推荐使用，

//利用闭包实现的另一种方法

var li = document.getElementsByTagName("li");
for (var i = 0; i < li.length; i++) {
  (function(j) {
    li[i].onclick = function() {
      console.log(li[j].innerHTML);
    };
  })(i);
}

//上面也是使用闭包产生若干个不同的不销毁的堆内存，

var li = document.getelementsByTagName("li");
for (let i = 0; i < li.length; i++) {
  li[i].onclick = function() {
    console.log(li[i].innerHTML);
  };
}
//上面这种方式和第一种类似，在ES6中使用循环体的{}会产生块级作用域
//循环体执行了几次，就产生了几个块级作用域，每个块级作用域中存储的i的值也不一样
//同样也是给不同的li绑定不同的堆内存地址，

var li = document.getelementsByTagName("li");
for (var i = 0; i < li.lengthl; i++) {
  li[i].addEventListener("click", function() {
    console.log(this.innerHTML);
  });
}
//由于this在事件当中给谁绑定的this就是谁，所以我们通过this也可以完成操作
//而且this也不会创建多余的堆内存。更加的节省性能，依次推荐这种方法
```

## 设计模式

在 js 中有许许多多的设计模式，合理的运用可以是我们的代码更加的高效整洁，实现**高内聚低耦合**

## 单例设计模式(singleton pattern)

- 单例设计模式简单理解为就是一个普通的对象，它可以将一个事务的属性和特征进行**分类** **归组** 统一存储在堆内存当中，可以减少我们全局变量的污染，在单例模式中，我们成为属性名为`命名空间[NameSpace]`，不同的命名空间是相互独立的，互不干扰

```javascript
var obj = { name: "xxx", age: 18 };
//如果我们不使用单例模式，那么就需要定义两个变量来存储这些信息，
//这样会过多的污染全局变量，并不利于我们的开发，
```

## 高级到单例设计模式

- 高级单例模式并不是普通的赋值，而是先创建一个匿名函数，该函数的堆内存并不会被销毁，因为它一直被`NameSpace`所占用，我们可以在这个匿名函数中创造很多的功能，如果有需要供外面使用的功能我们直接将其暴露到返回的对象中即可（模块化实现的一种思想）

```javascript
var obj = (function() {
  var a = 12;
  var fn =function(){};
  ...
  return {
    a : a,
    fn : fn
  }
})();

//上面这种我们就是用了高级单例模式，如果外部需要使用内部的功能，
//我们只需要将其放在一个对象中，然后返回，
//我们就可以直接在外部调用这些功能，这样可以减少我们全局变量的污染
```

## 工厂模式（Factory Pattern）

工厂模式实际就是把相同的功能封装在一个函数内，实现批量生产，工厂模式实现了高内聚低耦合的思想

```javascript
function createPerson(name, age, sex) {
  return {
    name: name,
    age: age,
    sex: sex
  };
}
var obj = createPerson("平野绫", 18, "女");
var obj2 = createPerson("钉宫", 20, "女");
//上面的代码中我们就是用工厂模式创建了连个不一样的对象，
//每一个执行函数所传入的实参是不一样的。那么return出的值也是不一样，
//工厂模式有很多中写法，区别最大的就是this的使用
```

## 模块化开发

1.团队协作开发的时候，会把产品按照功能板块进行划分，每一个功能板块有专人负责开发

2.把各个版块之间公用的部门进行提取封装，后期在想实现这些功能，直接的调取引用即可（模块封装）
