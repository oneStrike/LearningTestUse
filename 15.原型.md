#

## 原型（prototype）

1. 每一个函数在出生时都有一个属性`prototype`,它是一个对象，浏览器会自动为它创建一个堆内存，

2. 函数的`prototype`属性天生就拥有一个属性`constructor`,它存储的值就是当前函数本身

3. 所有的对象都拥有一个属性`__proto__`,他指向当前这个对象的所属类，如果它的所属类不明确，那么它就是指向`Object.prototype`。

我们应该着重注意`__proto__`的使用，因为 IE 屏蔽了它，禁止我们操作和使用。

```javascript
function Person(name) {
  this.name = name;
}

var person = new Person("绫"); //person是Person这个类的实例

//既然person是Person的实例，那么person的隐式原型就应该指向
//person的原型，那么下面的代码就应该返回true
console.log(person.__proto__ === Person.prototype); //=>true

//我们可以根据下面的一张图更加清晰的了解执行的步骤
```

![nhQuW9.png](https://s2.ax1x.com/2019/09/16/nhQuW9.png)

当我们访问一个实例的属性是会优先寻找自身有没有这个属性，如果有则直接返回，没有的话则是去原型中寻找，找到则直接返回，我们拿数组对象举一个例子，我们自己创建的数组中并没有`pop`,`splice`,`sort`等等这一系列的方法，但是我们却可以直接使用，因为我们使用的都是原型中的一些方法，如果是原型中的属性或者方法，我们只能使用，并不能修改或者删除，我们又是也可以创建一个同名的属性来遮蔽原型中的属性，这样的话就只能访问自身拥有的这个属性，并不会去原型中查找

![nhDpHe.png](https://s2.ax1x.com/2019/09/16/nhDpHe.png)

我们可以根据这个机制将一些实例共有的属性或者方法添加到构造他们的类的原型中，这样可以减少代码的耦合。使用起来也很方便。

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sex = "女";
var person = new Person("绫");
var person2 = new Person("钉");
console.log(person.name, person.sex); //=>'绫' '女'
console.log(person2.name, person2.sex); //=>'钉' '女'
//当我们给Person的原型中添加一个属性时，他的实例便都拥有这个属性，
//如果实例中的属性和原型中的属性重名时，只会使用自身的，
//实例无法修改原型中的所有属性，person.sex='男';只是给自身添加一个属性，
//或者是自身属性的再赋值，和原型中的属性没有任何关系
```

构造函数的原型也是一个对象，只要是对象就会拥有`__proto__`属性，但是原型不清楚自己的所属类是谁，那么它的`__proto__`就会指向`Object`的原型，`Object`也拥有原型，但是`Object`原型的`__proto__`指向的是`null`;

![nOKH6f.png](https://s2.ax1x.com/2019/09/19/nOKH6f.png)

原型链全貌

所有的函数永远都是内置`Function`的一个实例，而`Object`的原型则是原型链的最顶端，他所拥有的方法和属性可以供所有的函数或者对象使用

![nxO40K.png](https://s2.ax1x.com/2019/09/21/nxO40K.png)

## 原型重定向

> 在实际的开发（构造原型设计模式）当中允许我们修改一些类的原型指向！但是更改原型指向的一系列问题应该在开发中着重注意

1. 更改原型的指向那么原型中的`constructor`这个属性就不存在了。不单单是这个属性，先前所有的属性和方法都不能使用，原有的原型会触发浏览器的垃圾回收机制，自动清理掉，释放其内存空间，此时的`constructor`就会指向`Object`。

```javascript
function Fn() {
  var n = 10;
  this.m = 20;
  this.aa = function() {
    console.log(this.m);
  };
}
//new实例的时候Fn的原型并没有改变
//当前实例的__proto__仍然指向Fn先前的原型
//在后面的代码中仍然可以使用先前原型中的所有属性和方法
//因为当前的实例指向先前的原型，那么就不会触发浏览器的垃圾回收机制
//重定向原型之前创建的实例无法访问重定之后的属性和方法
var f1 = new Fn();
Fn.prototype = {
  aa: function() {
    console.log(this.m + 10);
  }
};
//此时Fn的原型已经被手动重定向了
//重定向原型之后再次new实例的话，这个实例就只能使用之后新指向的原型
//无法使用先前原型中所有的属性和方法，
//如果不设置constructor，默认会访问到Object的原型
var f2 = new Fn();
```

**手动设计`constructor`的指向**

当我们重定向原型之后，也可以重新设置`constructor`的属性

```javascript
function Test(){
  this.a = 100;
};
Test.prototype={
  constructor:Test;//设置constructor的指向，让其指向当前的构造函数
  this.b=200;
}

```

> 一般只有需要大量向原型中添加一些属性或者方法的时候，才会改变其原型的指向，**由于浏览器的保护机制！默认类的原型无法被改变**

```javascript

Array.prototype={};
//即使我们改变默认类的原型，但是依然不会生效


function Test() {
  //...
}
//需要大量添加一些属性和方法的时候可以直接重定向原型，
Test.prototype = function() {
  //...大量的属性和方法
};

//如果只是添加个别属性或者方法的话，可以直接添加到原型中，没必要重定向原型
Test.prototype.a = function() {
  //...   只是简单的添加一些属性或者方法的时候可以使用这个方法
};

//也可以把一些属性和方法放进一个对象中，一起添加进原型中，但是使用的时候会比较麻烦
var aa = {
  bb:function(){};
  //...  属性或者方法
};

Test.prototype.bb = aa;
//按照上面设置之后我们只能[实例].[对象].[属性名]这样访问
var f = new Test();
f.aa.bb()
```

## hasOwnProperty

`hasOwnProperty`可以验证一个属性或者方法是否是为自身拥有，他不会去原型链中寻找

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sex = "女";
var person = new Person("绫");
var person2 = new Person("钉");
console.log(person.name, person.sex); //=>'绫' '女'
console.log(person2.name, person2.sex); //=>'钉' '女'
console.log(person.hasOwnProperty("sex")); //=>false
console.log(person.hasOwnProperty("name")); //=>true
//当可以使用一个自身不拥有的属性或者是方法时，
//那么这些属性或者方法就一定存在有原型找中
```

## **\*归总练习题**

```javascript
function Fn() {
  this.x = 100;
  this.y = 200;
  this.getX = function() {
    console.log(this.x);
  };
}
Fn.prototype.getX = function() {
  console.log(this.x);
};
Fn.prototype.getY = function() {
  console.log(this.y);
};
var f1 = new Fn();
var f2 = new Fn();
console.log(f1.getX === f2.getX);
console.log(f1.getY === f2.getY);
console.log(f1.__proto__.getY === Fn.prototype.getY);
console.log(f1.__proto__.getX === f2.getX);
console.log(f1.getX === Fn.prototype.getX);
console.log(f1.constructor);
console.log(Fn.prototype.__proto__.constructor);
f1.getX();
f1.__proto__.getX();
f2.getY();
Fn.prototype.getY();
```

---

```javascript
function Foo() {
  getName = function() {
    console.log(1);
  };
  return this;
}
Foo.getName = function() {
  console.log(2);
};
Foo.prototype.getName = function() {
  console.log(3);
};
var getName = function() {
  console.log(4);
};

function getName() {
  console.log(5);
}
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

---

```javascript
function Fn() {
  var n = 10;
  this.m = 20;
  this.aa = function() {
    console.log(this.m);
  };
}
Fn.prototype.bb = function() {
  console.log(this.n);
};
var f1 = new Fn();
Fn.prototype = {
  aa: function() {
    console.log(this.m + 10);
  }
};
var f2 = new Fn();
console.log(f1.constructor);
console.log(f2.constructor);
f1.bb();
f1.aa();
f2.bb();
f2.aa();
f2.__proto__.aa();
```

## 内置类原型扩展

- 我们可以在基本类的原型中添加一些公共的方法，这样的话我们基于基本类所创造的所有实例都可以直接使用这些方法。

- 我们自己添加的方法不应该和原型中已经存在方法重名，因为这样的话会覆盖掉原型中原有的方法，所以我们应该在方法名中添加一些我们自己的标识，以便于更好的和原有的方法区分开。

```javascript
//我们就拿数组去重来做一个简单的示例
var arr = [1, 2, 3, 1, 2, 1, 1, 2, 3, 2, 1, 2, 2];
//直接将数组去重的方法添加进原型中。因为数组是基于Array所创造的实例,所以我们需要在Array的原型中添加
Array.prototype.myNoRepeat = function myNoRepeat() {
  //此处函数的名字并没有实际的意义，他只是为了让我门创造的
  //方法看起来和内置的更加接近而已
  var obj = {};
  //this代表当前调用这个方法的数组
  for (var i = 0; i < this.length; i++) {
    var item = this[i];

    obj.hasOwnProperty(item)
      ? ((this[i] = this[this.length - 1]), this.length--, i--)
      : (obj[item] = item);
    //并不建议使用三元表达式来计算结果，
    //因为这样看起来有点过于复杂了
    //并不利于我们阅读代码
  }
  obj = null;
  //可以提前将我们创建的对象所占用的堆内存释放，
  //稍微有利于性能，虽然并不明显

  return this;
  //为了我们以后能够衔接使用链式方法
  //此处应该将操作的对象返回。
};
```

> 这里讲一下上面代码中的一些优缺点吧

【 **优点** 】

1. 如果我们使用双重`for`来对数组进行去重，这样的操作会更加消耗我们的性能，因为这种方法是把数组中的每一项都拿出来和其它项进行对比，当我们数组想越多时对性能的影响也就越大，我们上面的代码利用了对象属性名的机制，只要发现属性名重复我们就把当前数组的元素和最后一项进行调换，然后将最后一项删除，这样不仅节省了性能，同时也避免了数组的塌陷问题（数组元素位置会发生改变）。

2. 我们在代码最后将我们创建的一个对象所占用的堆内存空间释放掉了。虽然这个性能提升微乎其微，但我们仍不应该忽略掉，同时也可以让我们的代码形成良好的规范。

---

【 **缺点** 】

1. 代码中的 this 只有当我们直接使用数组对象调用时才会正确的指向我们希望操作的对象，`arr.__proto__.myNoRepeat()`,这样子调用时 this 的指向就会出现错误，而且在 IE 中并不支持我们使用`__proto__`,因此代码也会报错！`Array.prototype.myNoRepeat()`这样也会使 this 指向错误，虽然我们几乎不会使用这些方法调用，但是仍应注意

2. 在我们借助了数组中元素的索引来完成了我们的需求，虽然这样会帮助我们节省性能，但是也会造成数组中元素的顺序发生改变，如果要求我们不能改变数组中元素的顺序，我们就不应该使用这种方法。

如果我们不希望改变数组元素的顺序，我们可以使用这面这种写法

```javascript
var arr = [1, 2, 3, 1, 2, 1, 1, 2, 3, 2, 1, 2, 2];
Array.prototype.myNoRepeat = function myNoRepeat() {
  var obj = {};
  for (var i = 0; i < this.length; i++) {
    var item = this[i];
    if (obj[item]) {
      this.splice(i, 1);
      i--;
      continue;
    }
    obj[item] = item;
  }
  obj = null;
  return arr;
};
//这样虽然不会对数组中元素的顺序造成影响
//但是会造成数组塌陷的问题，对性能会有影响，
```

数组塌陷：当我们删除数组中的某一项时，这个数组元素所有所有的元素都会向前进一步，如果数组中的元素比较多时，会对性能造成影响
