## 函数

函数在 js 中属于是一等公民，函数就是将一些我们经常使用的功能或者经常重复性使用的代码封装在一起，当我们需要使用的时候直接调用即可，函数为我们的开发提供了不可或缺的便利，同时函数中的形参和实参也让我们的开发更加的灵活多变，

【 **细节** 】

- 如果将一个函数作为表达式赋值给一个变量时，表达式运算结束后，当前的这个变量也会消失，

```javascript
var a = function f() {}; //此处的函数名f没有什么实质性的意义
console.log(a); //f函数本身的代码块
console.log(f); //Uncaught ReferenceError: f is not defined

var a = 1;
if (function f() {}) {
  a += typeof f; //此时的f并没有声明赋值，typeof检测时即使没有这个变量，也不会报错，
  //而是会返回undefined，此时if判断语句内的f函数运算完之后已经被销毁了
}
console.log(a); //字符串拼接:1undefined
```

## 创建函数

- 函数的创建的时候会自动开辟出一个新的堆内存，将函数的代码块以字符串形式的存储起来，栈内存与函数关联起来的是堆内存的内存地址。

- 函数创建的方式：函数字面量，函数表达式，匿名函数。

  - 函数字面量：基本格式为`function [函数名](){}`，函数字面量具有变量提升机制。
  - 函数表达式：基本格式为`var [变量名]=function(){}`,函数表达式只会声明提前，
  - 匿名函数：基本合适为`(function(){}())`,不具有变量提升，会直接执行，并且只能执行一次，除了不具有变量提升机制之外，和其他的函数都是一样的机制。

## 函数运行

- 函数字面量和函数表达式都需要使用`()`来调用， 但是匿名函数由于没有名字，所以当代码执行到当前的代码块的时候会直接执行，

- 函数在运行的时候会产生一个私有作用域，在私有作用域当中只有形参和使用关键字`VAR`声明的变量是私有变量，全局作用域当中是无法访问私有作用域中的私有变量，但是私有作用域经过**作用域链**却可以访问全局作用域中的变量。

## 形参实参

形参：形式上的参数，用于接收函数调用是传递的实参

- 在函数创建的时候可以在`()`中填写形参，形参就相当于在函数内部创建了一个变量，只不过没有赋值，函数在调用的时候，如果有传递实参，则最优先给形参赋值，形参在函数内部属于私有变量，全局作用与无法访问，形参名可以和全局作用域中的任何变量重名，

实参：函数调用时需要传递给形参的值

- 在函数调用的时候可以在`()`中填写需要传递的实参，如果传递的是表达式则会先计算出值然后在传递，如果是引用类型的则是传递其内存地址，(此时函数内部的形参会和全局作用域中的变量指向同一块内存空间)，函数也可以作为实参传递

形参和实参的数量可以不相等，在传递实参的时候，会按照顺序给形参赋值，如果实参数量少于形参数量，则多出来的形参值则是`undefined`,如果形参的数量少于实参，会先依次给形参赋值，多出来的形参并不会报错

## ES6 中的形参

【 **在 ES6 中可以直接给形参赋值(形参初始化)** 】

```javascript
function test(x = 0) {
  //只有在没有传递值或者传递的是undefined时才会赋值为0
  console.log(X);
}
test(null); //=>null
test(false); //=>false
test(undefined); //=>0  不传递实参x的值也是undefined，
//只要有传递实参并且传递的实参不是undefined，
//那么我们传递的是什么x就是什么
```

## 返回值

当我们基于函数实现一些功能的时候。我们有时候并不需要利用函数处理，只是单纯的希望函数能够把结果计算出来，至于计算的结果则由我们自由使用，或者是我们希望在外部仍然可以使用函数内部的东西，这时我们就可以使用`return`关键字来返回我们需要的东西，

1. 在函数中如果不使用`return`关键字函数也会自动在函数末尾添加，只不过返回的`undefined`，如果只书写`return`，后面不填写返回值的话，那么也会返回`undefined`。

```javascript
function test(a, b) {
  console.log(a + b); //30
}
test(10, 20);
var a = test(10, 20);
console.log(a); //=>undefined
//这个函数会在控制台输出a+b的结果，并没有返回值，
//即使我们使用一个变量接收，也只会得到undefined

//当我们需要操作相加结果的时候就可以将这个结果返回
function test(a, b) {
  console.log(a + b);
  return a + b;
  //=>返回a+b的结果到外部
}
var c = test(10, 20);
console.log(c);
//=>30，我们可以使用相加的结果做我们需要的操作
```

2. 我们可以在函数中返回任何数据类型，基本数据类型会直接返回值，而引用数据类型时则会返回对应的堆内存空间地址，我们甚至还可以返回一个函数

```javascript
function test(a+b){
  return a+b;
  }
  var a =test(10,20);
  console.log(a) //=>30
//上面这些代码则是利用了函数的返回功能，返回的结果是a+b的结果
//上面的函数只是帮我们出结果，并把结果返回给我们，
//这样可以使我们的操作更加灵活，因为我可以哪计算的结果做任何操作
//并不是单纯的做某一种操作

function test(){
  return function(){
    //这里可以书写我们使用的功能然后然后返回
  }//=>此处返回的是这个函数的堆内存地址
}
var result =test();
result()//=>调用函数的返回值
//我们可以返回一个函数，函数内书写这我们所想要使用的功能，然后用一个变量接收，
//之后我们想要使用这个功能的时候，直接调用这个返回值就可以了。
//我们甚至可以将多个功能放在一个对象中返回出来，
//这样做的的好处是可以减少全局变量的污染，也可以让我们的代码便于维护
```

3. 在函数执行当中，一但碰到`return`关键字，就会立即终止函数的执行，继而返回`return`关键字后的数据。

```javascript
function test(a, b) {
  var num = a + b;
  return;
  var num2 = a * b;
  return [num, num2];
}
var result = test(10, 20);
console.log(result); //=>undefined
//上面的函数只会返回undefined，因为我们函数在碰到return之后就会立即终止函数的执行，
//即使在下面再次书写一个return也得不到任何的结果，
```

## arguments

**`arguments`只在非严格模式中存在映射机制，在函数刚一开始运行的时候就已经决定好了。（只和当前传递的实参建立映射关系）。之后无论做什么样的操作，都没办法改变其映射关系**

1. `arguments`是所有函数中都拥有的类数组对象（ES6 中的箭头函数没有），并不是真正的数组对象，但是可以转换成真正的数组，

2. 他是函数所传递的实参的集合，并且拥有索引，索引从 0 开始，每传递一个实参会自动递加其索引值，将传递的值作为值存储起来，

3. 无论有没有形参接收实参，`arguments`的值都会增加，如果有形参接收实参，那么`arguments`的值会和形参形成映射关系，他们其中一个改变的时候另外一个也会改变，

4. 只有实参传递的值才会使`arguments`和形参形成映射关系，如果实参数量少于形参数量，那么后面手动给形参赋值并不会影`arguments`同时也不会递加自身的索引和值。

5. 可以采用`arguments[索引]`的方式来访问其索引中存储的值

6. 使用`typeof`时返回的是`object`,**说明是一个对象**

- 扩展小知识

  - `arguments`有一个属性叫做`callee`，他可以以返回当前函数的代码块，还有一个是`caller`,`caller`在使用前需要加上`callee`,正确的格式是`arguments.callee.caller`,如果直接使用`caller`则会返回`undefined`。他可以返回函数的执行的区域（也就是宿主环境，如果是在 window 下执行的则返回 null。**慎用，已经被标准所弃用**

**可以使用`Array.from(arguments)`将其转换成真正的数组**

## 函数的三种角色身份

函数在 js 中真的是一个神奇的存在，在 js 中他是一等公民，同时他还"身兼多职"。

1. 我们书写一个函数直接调用那么这个函数就是一个普通的函数

2. 函数也是对象，当我们给直接给函数添加一些属性或者方法时，这个函数就可以当作是一个普通对象，同时对象拥有的操作也同样具有

3. 每个函数都有一个原型，并拥有一些公共的属性或者方法供它下面的实例使用，但是函数却不能直接使用这些方法，但是它下面的实例却可以直接使用，这里的函数就是类

【 **函数的这三种关系并没有必然的练习，主要取决于我们怎么去使用** 】

## 构造函数（constructor）

- 在 js 中使用`new`关键字创建的函数我们称之为构造函数，为了和普通函数区分开，我们创建构造函数时一般都是使用大驼峰命名法来命名（每个单词的首字母都大写）。
- 使用`new`关键字创建构造含数，此时的函数名称为**类名**,而接收构造函数返回的变量时当前类的**实列**
- 在我们平时的开发当中一般很少直接书写构造函数，构造函数一般用于组件,框架,插件,类库的封装。
- 构造函数也叫做**对象构造器函数**

```javascript
function Test() {
  //....
}
var obj = new Test();
//上面的代码中我们就创建了一个简单的构造函数，Test就是我们创建的自定义类，而obj就是Test这个类的实例
```

### 创建值的两中方式

> 在 js 中创建值有两种方式:
>
> 1.  字面量方式
> 2.  构造函数方式

**引用数据类型的区别**

```javascript
var obj = {}; //=>字面量的方式创建对象
var obj = new Object(); //=>构造函数创建对象
```

- 上面代码中都是创建一个对象，只是创建的方式不一样，第一种时通过字面量的方式创建，我们可以直接在{}内书写代码，示例：`var obj = {name :'平野绫',age:18}`。我们还称这种为**单例设计模式**，即每一个都是一个单独的实例，创建多个时，每个实例之间的都是相互独立，互不干扰！

- 第二种通过**构造函数**的方式创建的，但是它不能直接在()内书写代码，必须使用`.`给对像添加属性。示例：`var obj = new Object();obj.name='平野绫';obj.age=18;`。这两种创建方式除了语法上的区别，并没有什么特殊点

**基本类型的区别**

js 中基本数据类型也可以通过这两种方式来创建数据，但是两种方式创建的数据是有区别的

```javascript
var num = 12; //=>字面量方式
var num2 = new Number(12); //=>构造函数方式
typeof num; //=>'number';
typeof num2; //=>'object';
```

通过上面的代码我们可以明显的看出即使值都为数字，但是数据类型却大不一样

> 通过字面量方式创建的数据类型为`number`，而通过构造函数方式创建的则是`object`，虽然这两种数据类型不一样，但是都可以使用`number`这个类的属性和方法。

### 构造函数的运行机制

> 构造函数的运行一共发生了一下几个步骤：

1. 创建私有作用域
2. 形参赋值，变量提升
3. 在代码执行之前创建一个新的堆内存，存储一个对象，this 指向该堆内存
4. 执行代码，同时遇到 this 关键字时就在新创建的堆内存内存储相应的键值对
5. 返回 this

```javascript
function Proson(name, age, sex) {
  var n = 10;
  this.name = name;
  this.age = n + age;
  this.sex = sex;
}
var obj = new Person("平野绫", 18, "20");
//我们可以通过下面的一张图详细了解构造函数的运行机制
```

[![nc5GLV.png](https://s2.ax1x.com/2019/09/15/nc5GLV.png)](https://imgchr.com/i/nc5GLV)

### 构造函数中的小细节

> 当我们创建一个当前类的实例时，实例只能拥有 this 的属性，如果构造函数内部的变量并没有个 this 关联，那么它只是一个单纯的私有变量，我们创建的实例不用于也无法访问这个变量。

```javascript
function Person(name, age) {
  var n = 10;
  this.name = name;
  this.age = age + n;
}
var person = new Person("平野绫", 18);
console.log(person.name); //=>'平野绫'
console.log(person.n); //=>undefined
//我们拥有并且可以访问和this相关联的变量，当前的n只是一个私有变量
//和我们创建的实例没有任何关系，因为他没有和this进行关联
```

> 普通函数拥有`return`方法，可以返回任意我们需要的数据，在构造函数中也拥有这个方法，只是在构造函数中我们无法返回基本数据类型，如果我们返回的是一个基本数据类型的话，浏览器会自动忽略掉所返回的数据，只会结束当前的构造函数执行，如果我们返回的是一个引用数据类型的话那么我们返回的时什么，外面接受的就时什么，此时的 this 就和外面接收返回值的变量没有关系，

```javascript
function Test(a, b, c) {
  this.a = b + c;
  this.b = a + c;
  return 123;
  //当我们使用return返回一个基本数据类型时，浏览器并不会给我们返回相应的值
  //我们书写return返回一个基本数据类型时。其实就相当于只书写了一个return结束循环
  this.c = a + b;
}
var result = new Test(10, 20, 30);
console.log(result.c); //=>undefined
console.log(result); //=>{a:50,b:40}
//其实result中并没有c这个属性，由于对象机制的原因，我们访问一个不存的属性时也会返回undefined

function Test(a, b, c) {
  this.a = b + c;
  this.b = a + c;
  return [];
  //当返回一个引用数据类型时，返回的是什么外面接收到的就是什么
  //此时的this就和外面接受的变量没有关系了
  this.c = a + b;
}
var result = new Test(10, 20, 30);
console.log(result.c); //=>undefined
console.log(result); //=>[];
```

## 作用域

在 ES5 中分为全局作用域和局部作用域。全局作用域指的是`widnow`所创建的栈内存，局部作用域指的是函数执行时所产生的局部作用域。在 ES6 中有了块级作用域，即大部分的{}都会产生一个一个块级作用域

1. 全局作用域：

   > 页面在一开始加载的时候就会产生全局作用域。只有关闭页面或者时刷新页面时才会销毁

2. 局部作用域：

   > 函数在执行的时候会产生一个新的局部作用域来执行函数内的代码，函数执行完毕之后就会销毁当前的作用域，函数的每一次执行都会产生一个全新的作用域，每次产生的作用域都是一个完全独立的

3. 块级作用域：

   > 块级作用域时 ES6 的规则，类似于函数的局部作用域，大部分的时候当代码中出现{}就会产生一个块级作用域，但是创建对象时候所使用的{}并不会产生块级作用域，因为他只是一个对象的书写形式，判断语句和循环语句中的{}则会产生块级作用域

## 作用域链

> 在函数执行创建时就会产生一个作用域链，作用域链是一个不可操作的类数据对象，函数创建的时候会在作用域链索引 0 的位置上和`widnow`全局作用域相关联， ![nymQLq.png](https://s2.ax1x.com/2019/09/14/nymQLq.png)

> 当函数执行的时候会自动将自身的作用域放在索引 0 的位置上，会将其他的依次向下位移一个索引，在查找一个数据时会按照作用域链优先查找索引 0 上的作用域，如果没有则依次向下查找，函数在执行完毕之后会销毁自身的作用域，作用域链会回到创建时的状态 ![nym3wV.png](https://s2.ax1x.com/2019/09/14/nym3wV.png)

> 如果在函数内部创建了一个函数，那么这个函数创建的时候作用域链就会和他的上一级函数相关链，此时索引 0 的位置上存放的是他上一级的作用域 window 全局作用域在作用域链中始终处于最底部，**函数的作用域链在创建的时候就已经决定好了。因此跟函数在哪运行没有任何关系** > ![nyuF58.png](https://s2.ax1x.com/2019/09/14/nyuF58.png)
