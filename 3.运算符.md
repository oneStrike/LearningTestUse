#

## 表达式(expressions)

表达式是由操作符，操作数，变量等一些列的组合。表达式会返回一个值，叫做**返回值**。表达式可以放在任何需要数据的地方

## 语句（statements）

语句则是由“;（分号）”分隔的句子或命令。如果在表达式后面加上一个“；”分隔符，这就被称为“表达式语句”。它表明“只有表达式，而没有其他语法元素的语句。

一般的 javascript 中的语句分为下面几种：

1. 声明语句：变量声明和函数声明
2. 赋值语句：把值或者表达式计算的值赋值给变量
3. 控制语句：能改变语句的执行顺序，包括条件语句和循环语句，当然还有比较特殊的标签语句。
4. 表达式语句：这些语句去掉最后分号，都也可当表达式用的。常见的有：对象操作（new、delete）、函数调用（函数执行，必有返回值）等。

## 操作符（Operator）和 操作数（Operand）

操作符：运算符，参与运算的符号

操作数：参与运算的数据，也称之为“元”

操作符不一定只有一个符号

操作符出现在不同的位置，可能具有不同的含义

```javascript
1 - 2;
//=>数学运算

-1.2;
//=>将一个数组变成负数

(1 + 2) * 3;
//=>():先计算()内的1+2；然后再*3

function test() {
  //...代码
}
test();
//=>():调用函数
```

## 分类

按操作数数量区分：

1. 一元（目）运算符：() . []
2. 二元（目）运算符: + - / \* % =
3. 三元（目）运算符: ?:

功能区分：

1. 算术运算符（数学）
2. 比较运算符
3. 逻辑运算符
4. 位运算符
5. 其他

## 数学运算符

数学运算符

1. `+ - * /`算数运算
2. `+ -`正负数
3. `%`求余
4. `++ --`自增自减
5. `**` 幂

### 细节

js 中的数学计算是不准确的，我们在开发中应该着重注意

```javascript
0.1+0.2=0.30000000000000004

0.14*100=14.000000000000002

```

【 **%（求余）** 】

`%`指的是一个数除以另一个数，不够除的部分就是余数

```javascript
9 % 4 = 1;
8 % 3 = 2;
2 % 2 = 0;
//=>如果可以除尽，那么余数就为0
2 % 3 = 2;
//=>被除数大于除数的话，结果是除数
```

【 **++/--** 】

- `++`和`--`的语法规范基本上是一样的，因此我们只拿`++`进行讲解

++代表的是在自身的基础上自增 1，分为前自增和后自增，我们在实际中应该着重注意前自增和后自增的区别

- 前自增是指++在前，他会使原有的值立即自增加 1。

```javascript
var b = 21;
console.log(++b);
//=>22;
//=>前自增表达式的值是自增之后的值
```

- 后自增是指++在后，他会在运算结束之后自增 1

```javascript
var a = 12;
console.log(a++);
//=>12
//=>后自增表达式的值是自增之前的值，在表达式运算完毕之后才会自增1
```

【 **以下规范不适用于（ + ）运算符** 】

在算数运算过程中会调用`Number()`方法将非数字类型转换为数字类型,然后在进行运算。

> NaN 虽然是数字，但它和任何数字作任何运算，得到的结果都是 NaN

- null：null -> 0

- undefined: undefined -> NaN

将对象类型先转换为字符串类型，然后再将该字符串转换为数字类型

对象类型 -> "[object Object]" -> NaN

【 **加号运算符** 】

当我们进行加法运算的时候只要有一边是字符串类型的时候，就不再是简单的数学运算了，而是会变成字符串拼接

```javascript
10 + true;
//=>11 正常的数学运算

10 + "10";
//=>'1010' 只要有一边是字符串类型的，就会变成字符串拼接
//=>字符串存储的值跟运算结果并没有什么关系

[12] + 10;
// =>'1210'
//=>虽然现在没看见字符串，但是引用类型转换为数字，首先会转换为字符串，
//=>所以变为了字符串拼接

({})+10
//=>"[object Object]10"

[]+10
//=>"10"

{}+10
//=>10
//=>这个和以上说的没有半毛钱关系，因为它根本就不是数学运算，也不是字符串拼接，它是两部分代码
//=>{} 代表一个代码块（块级作用域+10 才是我们的操作
//=>严格写法：{}; +10;

12+true+false+null+undefined+[]+'绫'+null+undefined+[]+true
```

如果是对象类型的则会有限转换成字符串然后在进行运算

数字 -> 数字字符串 boolean -> boolean 字符串 null -> "null" undefined -> "undefined" 对象 -> "[object Object]"

- 加号两边都没有字符串，但一边有对象，将对象转换为字符串，然后按照上面的规则进行
- 其他情况和上面的数学运算一致

优先级的运算细节：

1. 从左到右依次查看
2. 如果遇到操作数，将数据的值直接取出
3. 如果遇到相邻的两个运算符，并且左边的运算符优先级大于等于右边的运算符，则直接运行左边的运算符。

## 比较运算符

【 **比较运算符的返回类型：boolean** 】

【 **算术运算符的优先级高于比较运算符** 】

大小比较：

1. `>`大于
2. `<`小于

遵循一定的准换规则对两端进行大小比较

`Infinity` 比任何数字都大

`-Infinity` 比任何数字都小

相等比较：

1. `==`相等
2. `!=`不相等
3. `===`全等
4. `!==`不全等

- `==`和`!=`在比较时会遵循一定的转换规则进行比较，并不会进行数据类型的比较，
- 如果准换后的结果是一样的，那么就会返回`true`，否则返回`false`。
- `!=`是两边的不相等返回`true`如果相等的话则会返回`false`。

---

- `===`和`!==`并不会自动转换数据的类型，在比较时也会比较数据的类型
- `===`数据类型和值都相等则会返回`true`，否则返回`false`
- `!==`数据类型和值有一个不相等就会返回`true`，如果都相等返回`false`

1. 两个字符串比较大小，比较的是字符串的字符编码。
2. 如果一个不是字符串，并且两个都是原始类型，将它们都转换为数字进行比较
3. 如果其中一个是对象，将对象转换为原始类型然后，按照规则 1 或规则 2 进行比较
4. 如果两端都是对象类型，比较的则是对象的内存地址，因此大部分情况下他们都是不相等的

目前，对象转换为原始类型后，是字符串 "[object Object]"

【 **NaN 与任何数字比较，得到的结果都是 false** 】

1. null 和 undefined， 它们之间相等， 和其他原始类型比较， 则不相等。
2. 其他原始类型，比较时先转换为数字，再进行比较
3. NaN 与任何数字比较，都是 false，包括自身
4. Infinity 和-Infinity，自能和自身相等
5. 对象比较时，要先转换为原始类型后，再进行比较

【 **`null`和`undefined`他们相等，但是不全等** 】

```javascript
null == undefined;
//=>true 相等并不会比较数据的类型

null === undefined;
//=>false  全等会比较数据类型
```

【 **`Infinity` 和`-Infinity`只和自身相等** 】

## 逻辑运算符

【 **js 中的两个逻辑运算符都属于时短路运算符(存在的多个表达式时，只要有一个满足要求则不再运算其他的表达式)** 】

**逻辑与`&&`的优先级大于逻辑或`||`**

以下数据均判定为 false：

1. null
2. undefined
3. false
4. NaN
5. ''
6. 0

**逻辑与`&&`**

> 逻辑与：可以简单理解为寻找`false`,只要是第一个参数为`false`,则直接返回，如果第一个为`true`，则直接返回第二个。不做判断

我们通常在项目中用来判断一个是否传递了一个回调函数

```javascript
function test(callback) {
  //这种写法默认时要么不传函数，要传就要是一个回调函数
  //但是这中写法并不严谨，如果传的不是一个函数则会报错
  callback && callback();

  //严谨的写法应该是使用if判断
  if (typeof callback === "function") {
    callback(); //只有当传入的是一个函数时才会执行
  }
}
test(function() {
  console.log(123);
});
```

在判断体中使用逻辑与`&&`，则必须两边的条件都满足的话整体才满足

```javascript
var a = 12;
if (a && typeof a === "number") {
  console.log(123);
}
//上面的判断条件是a必须有值，而且a的值的类型还必须是number类型
//只要这两个条件都满足时才能进入判断体
```

**逻辑或`||`**

> 逻辑或：可以简单理解为寻找`true`,只要是第一个参数为`true`则直接返回，如果第一个为`false`，则直接返回第二个，不做判断

项目中我们通常用于参数的赋值

```javascript
function test(x) {
  x = x || 0;
  //如果有传递实参则直接返回x，没有的话则给x赋值为0
  //不严谨，如果我们传递的值转换为布尔值为false的话依然会赋值为0

  //严谨的写法
  if (typeof x === "undefined") {
    x = 0;
    //如果我们不传递实参，则x默认为undefined，就会进入判断
    //如果传递的是false或者是null之类的也不会进入判断。
    //但是传递undefined会进入判断
  }
}
test();
```

在判断体中是第一个满足直接返回，否则直接返回第二个

```javascript
var a = 10;
var b = 20;
if (a || b) {
  //只要a或者b有一个转换成布尔为true就可以进入判断
  console.log(123);
}
```

## 非

`!(非)`将数据的 boolean 判定结果直接取反，非运算符一定返回 boolean 类型。

对一个数据进行两次取反之后就会返回当前数据原有的`boolean`属性

```javascript
!false;
//=>true

!!false;
//=>false
```

## 条件运算符

三目运算符是 JavaScript 仅有的使用三个操作数的运算符。一般作为作为 if 语句的简短形式来使用

语法：条件`?`成立做的事情`:`不成立做的事情, <=>相当于简单的 if/else 判断

特殊情况

```javascript
//=>如果三元运算符中的某一部分不需要做任何的处理，我们用 null/undefined/void 0... 占位即可
var num = 12;
num > 10 ? num++ : null;

//=>如果需要执行多项操作，我们把其用小括号包裹起来，每条操作语句用逗号分隔
num = 10;
num >= 10 ? (num++, (num *= 10)) : null;
```

## 复合的赋值运算符

1. `+=`加等于
2. `-=`减等于
3. `/=`除等于
4. `*=`乘等于
5. `%=`余等于
6. `**=`幂等于
7. `>=`大于或等于
8. `<=`小于或等于

## 运算符优先级

数字越大优先级越高，当我们在做运算的时候不确定运算符优先级的时候

可以将我们需要运算的表达式用`()`将其圈起来，因为他的等级是最高的

![nvOVN4.png](https://s2.ax1x.com/2019/09/21/nvOVN4.png)

![nvOkHU.png](https://s2.ax1x.com/2019/09/21/nvOkHU.png)

![nvOiuV.png](https://s2.ax1x.com/2019/09/21/nvOiuV.png)
