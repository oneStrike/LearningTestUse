# JavaScript

js是一门单线程的解释型语言，并不需要进行预编译，而是在运行过程中进行解释，由于是单线程语言，所以一次只能执行一个任务，当前任务没完成时剩余的所有任务都需要等待。

js的标准由`ECMA`制定，但是`ECMA`只指定语言标准，并不涉及语言的运行环境，因此js可以在各种环境中执行，js的运行环境称为宿主环境，在`node`运行环境中可以编写服务器代码

`V8引擎`可以将js的代码直接转换为字节码来运行，理论上js代码的执行速度已经接近了汇编语言，同时由于`V8引擎`的出现，让js迈向了一个新的台阶

## 申请变量

### var

### let

### const

## 数据类型

| 类型       | 含义  |
|:----------|:------|
| String    | 字符串 |
| Number    | 数字   |
| Boolean   | 布尔   |
| Null      | 空    |
| Undefined | 未定义 |
| Object    | 对象   |
| Symbol    | 唯一值 |

数据类型分为**基本数据类型**和**引用数据类型**，在ES6中又新增了一种特殊的类型`Symbol`类型，表示唯一的值

### 基本数据类型

#### string

使用`""`，`''`，` \``
`包裹起来的都是字符串类型，无论字符串的内容是什么，即使没有内容，也被称为空字符串

- 实际的开发中除了` \``
  `以外我们需要统一使用字符串符号，因为单引号和双引号只是书写方式的不同，并没有实质性的不同
- `\`` `是ES6中新增的一种字符串，在进行字符串拼接的时候比前两者效率更高。

```javascript
var st = "";
var st2 = '';
var st3 = ``;
/**
* 都是字符串类型，内容为空，字符串的内容并不会影响变量的数据类型
* 字符串是由零到多个字符组成
*/
```

#### Number

数字数据类型，所有的正负数和小数都是数字类型。

- `NaN`（not is a number）是一个特殊的数字。
- `Infinity`表示无穷大，比任何数字都大。
- `-Infinity`表示无穷小，比任何数字都小。

```javascript
var num = 10;
var num2 = 10.2;
//=>都是数组类型
var num3 = '10';
//=>字符串类型，即使内容是数字
```

> `number`中的`NaN`虽然不是一个合法的有效数字,但是它的数据类型仍然是`number`类型,当一个值无法成功的转换为有效的合法数字或者两个值做数学运算无法获取正确的结果的结果的时候都会产生`NaN`;

```javascript
var st = '3';
Number(st);
//=>无法成功的转换为有效数字,直接返回NaN
```

> `NaN`是一个特殊的数字,和任何值都不相等,即使是`NaN`

```javascript
NaN === NaN;
//=>false;NaN和任何值都不相等
```

> 检测一个值是不是`NaN`的时候只有使用`isNaN`才能正确的检测

- `isNaN`会返回一个布尔值用于判断该值是不是`NaN`
- 是`NaN`返回`true`
- 不是`NaN`返回`false;`

```javascript
var nan = NaN;
if(nan === NaN){
  //=>永远无法进入判断语句,因为NaN和NaN作比较永远都是false
}

if(isNaN(nan)){
  //=>如果是NaN则可以进入判读体
  //=>如果是一个有效的数组则不会进入
}
```

#### Boolean

布尔类型，只有两个值
- `true`>真
- `false`> 假

```javascript
var boo = true;
var boo = false;
//=>手动赋值只有这两种书写方式
```

#### null

表示为空，只有一种书写方式，且只能手动指定这个类型，

- 存在一个历史遗留问题，检测数据类型时为`object`，需要细查

```javascript
var test = null;
//=>只有手动赋值为null时该变量才为null
```

#### undefined

只有这一中书写方式，申请一个变量不进行赋值，该变量的值就是`undefined`；

### 引用数据类型

#### 普通对象

对象数据类型，不同的对象拥有不同的数据结构，

- 普通对象都是由`{}`包裹起来的，有零到多组属性名和属性值组成，
- 属性名用来描述当前对象的特征，属性值是当前对象所具备的特性
- 一组属性名和属性值也称作是键值对，属性名=键(key)，属性值=值(value)
- 属性值可以是任意数据类型，属性名则只能是字符串类型，非字符串类型会被转换

```javascript
var obj = {};
//=>普通的空对象，没有任何属性

var obj2 = {name:'平野绫',age:20};
//=>拥有属性的对象
```

对象的属性名不仅仅可以是字符串格式的,还可以是数字格式的,当指定的对象属性名不是字符串或者是数字格式的时候,浏览器会默认的将只当的属性名通过`toString()`方法转换为字符串格式,如果设置的是数字格式的则无法使用`.`语法进行访问操作,只能使用对象表达式的方式

```JavaScript
var obj = {name:'平野绫',0:20};
obj.0;
//=>报错:Uncaught SyntaxError: missing ) after argument list

obj[0];
obj['0'];
//=>这两种访问方式都可以正确的操作对象
```

**增删改查**

**查**

普通对象拥有两种查询方法,
1. 字面量,使用`.`
2. 表达式,使用`[]`

- 访问一个不存在的属性时并不会报错,而是会返回`undefined`
- 在对象创建之前访问对象的属性会直接报错

```javascript
var obj = {name:'平野绫',阿哥:20};
//=>字面量方法的查询直接使用 对象.属性名 即可
obj.name;
//=>平野绫
obj.sex;
//=>undefined,不存在sex属性]
```

> 直接使用对象表达式访问一个对象的属性的时候,属性名需要使用字符串的格式,如果使用的是一个变量,那么会将变量中存储的值取出进行访问,当对象中不存在这个属性时则会返回`undefined`,只有当变量中存储的值和对象的属性名相匹配才能正确的访问

```javascript
var obj = {name:'平野绫',age:20};
obj['name'];
//=>使用字符串格式才可以正确的访问

obj[name];
//=>无法获取正确的数据,返回undefined
//=>name变量并不存在,也没有值,实际的访问表达式是obj[undefined]

var name = 'name';
obj[name];
/**
* 可以获取正确的数据,实际访问的实际obj['name']
* 如果name变量中存储的值与对象的属性名不匹配,
* 那么也无法获取到正确的数据
*/
```

**增**

给对象添加新的属性,如果需要添加的属性已经存在,那么就是修改

```javascript
var obj = {name:"平野绫",age:20};

obj.sex='女';
//=>对象中不不存在就是添加

obj.name='钉宫';
//=>修改属性,因为对象总已经拥有name属性

/**
* 通过对象表达式的方式我们可以指定任意类型的数据结构作为对象的属性名,
* 除了字符串和数字类型之外,都会被使用toString()方法转换为字符串进行存储
*/
obj[{}]=30;
//=>可以正确添加属性,实际添加的结构是'[object Object]':30

obj[{}];
//=>可以正确的访问属性,
obj['[object Object]'];
//=>直接使用转换后的字符串也可以获取到正确的属性值
```

**改**

修改对象已有的属性,如果修改的属性不存在就是给对象添加属性

```javascript
var obj = {name:'平野绫',age:20};

obj.age=18;
//=>修改属性

obj.sex='女';
//=>对象中并不存在sex属性,这个操作就是给对象添加新的属性
```

**删**

删除对象的属性,使用`delete`关键字,删除成功后会返回布尔值`true`,删除一个不存在的属性时也不会报错!

```javascript
var obj = {name:'平野绫',age:20};

delete obj.name;
//=>成功删除对象的name属性,返回true

delete obj.sex;
//=>删除不存在的属性不会报错,返回值也是true

delete obj['name'];
//=>通过对象表达式的方式删除
```

使用普通方式创建对象的时候,如果不添加任何的属性,那么这个对象就是一个空属性的对象,但是并不是完全意义上的空对象,因为这个对象拥有从原型中继承的属性和方法,但是平时所说的空对象值得就是没有添加任何属性的对象,跟他在原型中有没有继承属性或者方法没有关系

```javascript
var obj = {};
//=>拥有从原型汇总继承属性或者方法

Object.create(null);
//=>完全的空对象,没有任何属性,也没有从原型中继承任何属性或者方法
```

![n6W8dH.png](https://s2.ax1x.com/2019/09/14/n6W8dH.png)

#### 数组对象

数组也时对象数据类型的,也是由键值对组成,每一个数组中都拥有一个`length`属性,该属性存储的是数组的长度

> 数组都拥有索引(下标),索引从0开始递增,获取数组的某一项就是通过索引获取,
> 一个数组的最大索引值比数组的`length`小一

```javascript
var arr = [10,20,30];
/**
* 数据结构
* 0 : 10
* 1 : 20
* 2 : 30
*/
arr[0];
//=>获取数组的第一项
arr[arr.length-1];
//=>获取数组的最后一项
```

数组的值可以是任意的数据类型,也可以是另一个数组

```javascript
var arr = [10,'20',null,undefined,{},[40]];
/**
* 当一个数组中嵌套另一个数组,这个数组就会变为多维数组
* 根据嵌套的等级可以分为二维数组,三维数组等
* 在实际开发中为了操作方便,通常不会对数组进行太多层级的嵌套
*/
```

#### 日期对象

## 数据类型检测

### isNaN

- `isNaN`只有一个作用就是检测一个数值是不是`NaN`这个特殊的数字类型
- `isNaN`在进行检测的时候会将非数字类型的值通过`Number()`转换为数字类型再做检测
- 引用类型先使用`toString()`转换为字符串之后在使用`Number()`转换为数字
- `Number()`方法在遇到除`.`以外的所有非法字符都会转化为`NaN`,无论非法字符存在什么位置上

```javascript
isNaN('3');
//=>false,纯数字字符串可以转换

isNaN('3px');
//=>true,存在非法字符,无法转化内

isNaN('3.12');
//=>false,Number()可以将小数转换为正常的数字

isNaN({});
//=>true,对象类型无法转换为有效数字

isNaN(undefined);
//=>true,undefined无法转换为有效数字

isNaN(null);
//=>false

isNaN(0/0);
//=>0 / 0 的结果是NaN,这是一个特殊情况,其他数值除以0将不会是NaN

isNaN('');
//=> 空字符串可以转换为数字0

isNaN([10]);
//=>false,只有一个数组项时可以转换为数字

isNaN([10,20]);
//=>true;存在多个数组项是无法成功转换
```

### typeof

- 用来检测一个值的数据类型,无法细分的检测,检测的数据类型以字符串的格式返回
- `typeof variable`和`typeof(variable)`效果一样,只是书写方式有区
- 检测引用数据类型时总会返回`object`,无法检测具体的数据类型

```javascript
typeof 1;
//=>'number';

typeof('1');
//=>'string'

typeof null;
//=>'object',特殊情况

typeof undefined;
//=>'undefined'

typeof {};
//=>'object'

typeof [];
//=>'object'

typeof typeof {};
//=>'string',两个typeof检测永远会返回string,因为第一个的返回值时字符串类型
```

- 检测不存在的变量或者在变量申请之前检测都不会把报错,而是会返回`undefined`
- 基于`let`申请的变量改正了这一机制,在变量声明之前检测会报错

```javascript
typeof a;
var a = 1;
//=>undefined;申请之前检测不会报错

typeof b;
//=>undefined;变量不存在也不会报错

typeof c;
let c = 2;
//=>报错Uncaught ReferenceError: Cannot access 'b' before initialization
    at
```

### in

- `in`可以检测对象自身或者原型中是否拥有某一个属性
- 如果对象的属性值已经被删除则返回`false`
- 对象的属性值和检测没有任何关系,即使值为`undefined`,只要属性存在依旧返回`true`

```javascript
var obj = {name:'平野绫',age:20};
'name' in obj;
//=>true

'toString' in obj;
//=>true;原型中拥有toString方法

name in obj;
/**
* false,in操作符的右边应该是一个字符串格式的属性名
* 如果不添加字符串则认为是一个变量,会将变量存储的值取出在检测
* 如果变量的值和对象的属性名一致也会返回true
*/
```

### instanceof

- 检测一个构造函数的`property`属性是否出现在某一个实例中
- 如果检测的是一个表达式,那么会先将表达式的值计算出再做检测

```javascript
function Person (name,age){
  this.name=name;
  this.age=age;
  //=>创建一个构造函数
}

var son = new Person('平野绫',20);
//=>构建一个实例

son instanceof Person;
//=>true,可以用来检测一个实例是不是某一个构造函数的实例

```

### constructor

所有的对象都会从它的原型中继承这个属性,`constructor`指向构造出这个对象的构造函数

```javascript
function Peroson(name,age){
  this.name=name;
  this.age=age;
}
let son = new Person('平野绫',20);
son.constructor===Person;
//=>true;
```

### hasOwnProperty

- 检测一个属性是否是自身拥有,
- 自身不存在原型中存在也会返回`false`
- 需要检测的属性书写为字符串格式,如果是变量则会取出变量的值进行检测
- js并没有保护`hasOwnProperty`关键字,如果使用则会返回意想不到的结果

```javascript
let obj = {name:'平野绫',age:20};
obj.hasOwnProperty('name');
//=>true;
obj.hasOwnProperty('toString');
//=>false,原型中拥有,自身没有

let obj2 = {hasOwnProperty:function (){return fasle},aeg:20};
obj.hasOwnProperty('age')
//=>false,调用的是obj的hasOwnProperty属性,并不是真正的

({}).hasOwnProperty.call(obj,'sex');
//=>true,使用原型中的,并使用call将this改成obj

Object.hasOwnProperty.call(obj,'sex');
//=>效果一样
```

## 数据类型转换

### 数字

1. `Number()`
2. `parseInt()`,
3. `parseFloat()`

- `Number()`在遇到`.`以外的任意非法字符会转换为`NaN`,可以转换小数
- `parseInt()`首位遇到非法字符是转换为`NaN`,只转换整数
- `parseFloat()`首位遇到非法字符转换为`NaN`,可以转换小数

> 引用数类型在进行转换的时候会先使用`toString()`方法转换为字符串后在进行数字的转换,

| 类型       | 结果 |
|:----------|:----|
| ''        | 0   |
| null      | 0   |
| false     | 0   |
| true      | 1   |
| undefined | NaN |

```javascript
Number('1');
//=> 1
Number('1.1');
//=>1.1
Number('1px');
//=>NaN
Number([10]);
//=>10,数组只有一项可以转换
Number([10,20]);
//=>NaN,无法转换拥有多个数组项的数组
Number({});
//=>NaN;无法转换引用数据类型
```

> `parseInt`和`parseFloat`都是从左往右依次转换,在遇到第一个非法字符时将前面的直接返回,如果第一个就是非法字符,那么结果就是`NaN`,`parseInt`遇到`.`也会返回`parseFloat`则不会

```javascript
parseInt('1px');
//=>1
parseInt('1.1');
//=>1;会将小数部分过滤
parseInt([10]);
//=>10
parseInt([10,20]);
//=>10,多项数组只会转换第一位
parseInt('x199');
//=>NaN,第一位是非法字符时无法成功转换
```

```javascript
parseFloat('1.1');
//=>1.1;可以转换小数
parseFloat([10,20]);
//=>10;只转换第一位
```

> 在进行数学运算或者是`==`比较时,非数字类型会被默认的基于`Number()`方法进行数字转换

### 字符串

- 进行字符串拼接的时候,会默认将非字符串类型转换为字符串
- 手动调用`toString`,`join`,`toFixed`等方法的时候
- 除了对象以外都是直接将字面量转换为字符串

```javascript
[10,20,30]+'';
//=>'10,20,30'

({age:1})+'';
//=>'[object Object]'

[]+'';
//=>''
```

### 布尔

- 使用`!`,`!!`,'Boolean()'进行转换

1. `''`
2. `null`
3. `undefined`
4. `0`
5. `NaN`

> 除上述以外转换为`false`,其余都为`true`

### 细节

两个值进行`==`比较时,都会将非数字类型的值转换为数字类型在进行比较

| 表达式        | 转换过程 | 结果   |
|:-------------|:--------|:------|
| 1==true      | 1==1    | true  |
| 1==false     | 1==0    | false |
| 2==true      | 2==1    | false |
| \[\]==true   | 1==0    | false |
| !\[\]==true  | 1==0    | false |
| \[\]==false  | 0==0    | true  |
| !\[\]==false | 0==0    | true  |


## 输出语句

在js中所有的输出语句都是有宿主环境提供的

#### alert

把内容以弹框的方式在浏览器中输出，如果输出的值是一个表达式则会将表达式的值计算出之后再进行输出,被输出的值会被使用`toString()`转换为字符串

```javascript
alert(1);
//=> '1'
alert(1+1);
//=> ‘2’
//=>先计算值，在输出，

alert('');
//=>空字符串不会输出任何内容

alert([]);
//=>不会输出人任何内容，空数组转换后内容为空

alert({});
//=>[object Object]
/**
* alert在对内容进行输出的时候会将内容通过toString()进行转换，
* 无论内容的数据类型是什么，都是进行转换，
* 引用数组类型在进行转换的时候会使用原型链中的toString()进行转换，
* 普通对象会使用Object的toString方法，这个方法默认的结果就是输出值的类型，而不是转换后的结果
* 数组对象，时间对象等等则可以对值正常的输出，那时因为他们原型链中的toString
* 被重写了
*/
```

#### confirm

和`alert`的用法是一致的，只不过会增加确定和取消两个按钮,根据用户点击按钮的不同，会返回一个布尔值,同时也会对输出的值进行转换

```javascript
var flag=confirm('是否退出浏览器');
//=>点击确定返回true
//=>点击取消返回false
```

#### prompt

可以在弹框内输如内容，输出的内容为提示信息，会将用户输入的值作为返回值

```javascript
var test = prompt('提示信息');
//=>用户输入的内容就是test变量的值
```

#### console

在浏览器的控制台输出内容

- console.log()打印出需要打印的信息
- console.dir()更加详细的打印出信息

## 运算符

在js中拥有许多的运算符,同一个运算符拥有不同的功能,出现的位置不同,运算符的功能也会不同

### 数学运算符

| 运算符 | 含义   |
|:------|:------|
| +     | 加 /正 |
| -     | 减 /负 |
| *     | 乘     |
| /     | 除     |
| %     | 取余   |
| ++    | 递增   |
| --    | 递减   |

- 在数学运算过程中会将非数字类型通过`Number()`方法转换为数字类型再做运算
- 非数字类型无法转换为有效的数字时运算的结果就是`NaN`
- `NaN`虽然是数字类型,但是任何数字和它做运算结果都是`NaN`
- 对象类型会先使用`toString()`方法转换为字符串然后再通过`Number()`方法转换为数字

**以上规则不适用于`+`运算**

```javascript
1+2;
//=>3
1+true;
//=2
1+undefined;
//NaN,undefined无法正确的转换为有效数字

1+null;
//=>1,

//=>对象类型无法进行正常的数学运算
1+{};
//=>'1[object Object]'
1+[10];
//=>'110'
1+[];
//=>'1'

1+'1';
/**
* '11'
* 字符串11,只要是做+运算时,只要有一边出现字符串
* 无论另一边是什么数据类型,都是单纯的字符串拼接
* 不再是数学运算,出现引用数据类型也无法进行数学运算
*/
```

> 求余`%`是一个数除以另外一个数的整型余数,如果被除数大于被除数的话会直接返回除数

```javascript
3 % 2;
//=>1,整数除尽后剩余的数字
3 % 4;
//=>3小于被除数时直接返回除数
8 % 4;
//=>0,可以除尽就没有余数,结果就是0
```

> `+`和`-`除了作用与数学运算之外,还有正负数的作用,同时也会默认的将非数字类型转换为数字类型,

- `-`成功转换后的都是负数
- `+`成功转换后的都是正数
- 无法成功转换的返回`NaN`
- 转换并不会改变原有的数值,表达式会返回转换后的值

```javascript
var num = '2';
-num;
//=>-2,将字符串转换为数字-2
+num;
//=>2,将字符串转换为数字2

var st = '3.14';
+st;
//=>3.14,可以成功转换小数

var obj ={};
+obj;
//=>NaN,对象无法成功转换为数字

var arr = [10];
+arr;
//=>10,数字
//=>如果数组只有一个数组项,并且可以成功转换为数字类型时,仍然有效
```

**递增和递减拥有同样的运算规则**

- `++`分为前递增和后递增,运算符在前为前递增,运算符在后为后递增
- 前递增会使当前运算的数字立即增加1,
- 后递增会在表达式运算结束后增加1,
- 字符串可以成功转换为数字类型时也可以递增,无法转换为数字类型时递增为`NaN`

```javascript
var num = 1;
num++;
/**
* num++这个表达式在运算结束之前num都不会递增1
* 只有当表达式运行结束后才会使num+1;
* 可以理解为num++这个表达式的返回值就是需要递增的原数字
* console.log(num++)
* //=>1,表达式运算没有结束,
* console.log(num)
* //=>2,表达式运算结束后递增
*/

++num;
/**
* console.log(++num)
* //=>3
* console.log(num)
* //=>3
* 前递增会立即将原有的数字递增1,
* 不需要等到表达式运算结束
*/
```

### 逻辑运算符

| 运算符 | 含义   |
|:------|:------|
| &&    | 与    |
| \|\|  | 或    |
| !     | 非    |
| !!    | 双重非 |

逻辑或和逻辑与都是短路运算符,存在多个表达式时只要有一个表达式符合他们的规则就不在运算其他的表达式,逻辑与的优先级要大于逻辑或

- 在逻辑与运算符中第一个参数或者是表达是的结果是`false`时就会直接返回
- 如果第一个为`true`,则直接返回第二个,不会进行运算
- 在判断体中逻辑与的两边的条件都必须满足才会进入判断体
- 在非判断体中可以将逻辑与理解为寻找`false`,左边为`false`直接返回

```javascript
var test = 1;
var test2 = false;
var test3 = test && test2;
/**
* 赋值语句中的逻辑与
* 如果test转化为布尔值时false,那么test3的值就是test的值
* 如果test转化内为布尔值时true,那么test3的值就是test2的值
*/

if(test && test2){
/**
* 只有在test和test2的值都为true的时候才可以进入判断体
*/
}

//=>有时候也可以用于判断一个函数是否传递了回调函数
function test(callback){
  callback && callback();
  /**
  * 如果callback传递的是一个函数,那么转换为布尔值就是true
  * 为true时就会执行逻辑与右边的表达式,即是执行这个回调函数
  * 
  * 并不严谨的写法,如果函数内传递的不是一个回调函数,
  * 那么程序会直接出错,Uncaught TypeError:callback is not a function
  */
  
  if(typeof callback === 'function'){
    //=>严谨的写法,只有当callback是一个回调函数时才会执行
  }
}
```

- 在逻辑或运算符中第一个参数或者表达式转换为`false`时会直接返回第二个结果
- 如果第一个是`true`则直接返回第一个,就会停止运算
- 在判断体中只要有一个是`true`就会进入判断体
- 在非判断中可以将逻辑或理解为寻找`true`,左边为`true`直接返回,

```javascript
var test = '1' || 0;
/**
* 左边的值或表达式转换为布尔值是true
* 所以直接将'1'赋值给test
* 右边的表达式将不会运算
*/

if(test || test2){
  /**
  * 只要时test转换为布尔值时是true
  * 不管test2存不存在都可以进入判断体
  */
}

function test (x){
  x = x || 0;
  /**
  * 如果传递了参数则直接将参数的值赋值给x
  * 没有传递参数就将x赋值为0
  * 不严谨的写法,如果传递的参数转换为布尔值为false
  * 的时候,仍然会被赋值为0
  */
  
  if(typeof x === 'undefined'){
    x = 0;
    /**
    * 严谨的写法,x没有接收到实参或者实参是undefined
    * 的时候才会进入判断体,x才会被赋值为0
    */
  }
}
```

> 逻辑非可以将布尔值进行取反,同时也会将非布尔类型转换为布尔类型,双重非也会将数据类型进行转换,但是不会取反(取反两次就是原有值),可以使用双重非将一个数据转换为布尔类型

```javascript
!0;
//=>true

!!0;
//=>false
```

### 比较运算符

| 运算符 | 含义    |
|:------|:--------|
| >     | 大于    |
| <     | 小于    |
| >=    | 大于等于 |
| <=    | 小于等于 |
| ==    | 相等    |
| !=    | 不相等   |
| ===   | 全等    |
| !==   | 不全等   |

- 比较运算的表达式都会返回一个布尔值用以表示比较结果
- 两边都是字符串的时候比较的时字符串的字符编码
- 只要有一个不是字符串,就会将两边的值都转换为数字类型进行比较
- 两边都是对象,比较的是对象的内存地址是否相同,
- `null`和`undefined`直接相等,但是不全等
- `NaN`与任何数字比较都会返回`false`,包括自身
- `Infinity`和`-Infinity`只和自身相等
- `0`和`-0`是相等的

**以上规则不适用于`===`和`!==`**

```javascript
1 > 2;
//=>true
1 < 1;
//=>false

1 >= '1';
//=>true,大于或等于都会返回true

1 == '1';
//=>true,自动将字符串转换为数字类型,比较转换后的值

1 != '2';
//=>false

var obj = {};
var obj2 = {};
obj == obj2;
//=>false,两个对象的内存地址并不相同

var obj = {};
var obj2 = obj;
obj == obj2;
//=>true;两个对象的内存地址相同

null == undefined;
//=>true,不严格相等
null === undefined;
//=>false
```

- `===`和`!==`在进行比较的时候并不会转换比较值的数据类型
- 而是直接以数据的原有类型直接进行比较
- 如果数据类型不同,即使转换后的值是一样的,也会返回`false`

```javascript
1 === '1';
//=>false,全等会比较数据类型,不会进行转换

1 !== '1';
//=>true,数据类型不同

var obj = {};
var obj2 = obj;
obj === obj2;
//=>true;全等比较只要是内存地址相同也会返回true
```


### 条件运算符

条件运算符也可以称作是三元运算符,是js中唯一一个可以使用三个操作数的运算符,可以将三元运算符看作是简单的判断语句

条件表达式 ? `true`返回值 : `false`返回值;

- 当条件表达式的值转化为布尔值是`true`的时候就会直接返回第一个
- 如果值是`false`则返回第二个
- 如果希望三元运算符中的某一不部分不做任何的处理,使用`null`或`undefined`占位即可

```javascript
var num = 10;
num >= 10 ? num++ :num--;
//=>num大于或者是等于10的时候num就递增1,否则就递减1

//=>三元运算符可以嵌套使用,但并不建议嵌套使用
num >=10 ? (num <= 20 ? num+=2 : num--) : num +2;
```

### 解构赋值

结构赋值是ES6中新增加的一种js表达式,可以将对象或者是数组中的值取出赋值给表达式左边的变量

- 解构赋值也可以克隆数组,克隆的数组和原数组并不在同一内存地址,像个数组不相等
- 左边的赋值变量数量和右边的结构出值的数量不相等时会将前面的值赋值给变量,剩余的值不做处理

```javascript
var arr = [10,20,30,40,50];
var newArr = [...arr];
/**
* var newArr = arr;
* 两个赋值语句的结构是一样的
* 但是通过结构赋值克隆的数组和原有数组
* 并不处在同一内存地址中,
* 
* 后者只是直接将原数组的内地地址克隆给新的数组
* 原数组或者新数组只要有一个改变,另一个也会跟着改变
*/

var newArr = [...arr,60,70];
/**
* 克隆数组时也可以添加新的值
* 根据添加值的位置决定在新数组中的位置
* 如果添加值在解构赋值之前,
* 在新数组中添加值也会在解构赋值之前
*/

var [a,b]=arr;
/**
* a = 10;
* b = 20;
* 只会将数组的前两位的值赋值给左边的变量
* 剩余的数组项不做任何处理
*/
```

- 为防止结构出的值`undefined`,可以给赋值的变量添加默认值,
- 解构赋值可以简单将两个变量的值交换,不需要第三个临时变量
- 结构赋值也可以过滤掉不需要的部分

```javascript
var arr = [10,"",undefined,null,false,];
var [a=1,b=2,c=3,d=4,e=5,f=6] = arr;
/**
* 运算后的结果 :
* a = 10;
* b = "";
* c = 3;
* d = null;
* e = false;
* f = 6;
* 
* 只有当值是undefined或者没有接收到值时才会使用默认值
* 接收到undefined之外的任何值默认值都不会生效
*/

var a = 10;
var b = 20;
[a,b] = [b,a];
/**
* 最简单的方法交换两个变量的值
* 
* var c = a + b;
* a = c - a;
* b = c - b;
* 使用第三个临时变量交换连个变量的值
*/

var arr = [10,20,30];
var [a,,b] = arr;
/**
* a = 10;
* b = 30;
* 需要过滤的部分使用 , 隔开即可
* 过滤几个数值书写几个 , 即可
* 不过这并不经常使用
*/
```

- 当结构时也可以使用剩余模式,将剩余的部分都赋值给一个变量
- 使用剩余模式时,最后一个赋值变量之后不允许出现任何变量,出现`,`也会报错

```javascript
var arr = [10,20,30,40,50];
var [a,b,...c] = arr;
/**
* a = 10;
* b = 20 ;
* c = [30,40,50];
* 
* 将数组前面的值合理分配后,将剩余的数组项赋值给一个变量
* 使用剩余模式赋值的变量一定是一个数组,
* 即使是只接收到一个值,
*/
```

- 结构一个对象时,左边的赋值变量需要与右边结构的对象的属性名一致,如果名称不一致,那么将不会获得人任何值,
- 对象的结构与赋值变量的书写顺序没有任何关系,对象的解构赋值匹配的规则是根据对象的属性名与赋值变量名是否一致
- 对象解构时会查找原型链,自身没有的属性获取原型中查找

```javascript
var obj = {name:'平野绫',age:20,sex:'女'};
var {name,age,sex} = obj;
/**
* name:'平野绫',
* age:20,
* sex:'女'
* 即使将name,age,sex他们的位置调换
* 他们接收到的值也不会有任何变化
*/
```

- 对象的结构赋值也可以设置默认值
- 同时对象的结构赋值也可以设置接收变量的别名

```javascript
var obj = {a:1,c:3};
var {a=4,b=5,c=6};
/**
* a:1,
* b:5,
* c:3
* 只有当对象的属性值时undefined或者不存在时
* 设置的默认值才会生效
*/

var obj = {a:1,b:2,c:3};
var {a:aa,b:bb,c:cc}=obj;
//=>设置别名之后只可以使用别名访问获取到的值


var obj = {a:1,c:3};
var {a:aa=4,b:bb=5,c:cc=6};
/**
* 起别名的同时设置默认值
* aa:1,
* bb:5,
* cc:3
*/

var obj = {name:'平野绫',age:20};
var {name,age,toString} = obj;
//=>toString可以获取到原型中的值
```

> 当需要赋值的变量已经提前申请了之后,如果进行结构赋值需要使用`()`包裹起来,如果不是用`()`进行包裹,js将不会认为这是一个表达式,而是会将左边认为是一个独立的代码块,同时你的上一个语句执行完毕之后需要使用`;`进行分割,否则他有可能会被认为是一个函数调用

```javascript
var a,b;
var obj = {a:1,b:2};

{a,b} = obj;
//=>报错:Uncaught SyntaxError: Unexpected token '='
  
({a,b} = obj);
//=>正确的写法
```

- 在函数中可以替代`arguments`,同时解构赋值接收到是一个真数组,并不是伪数组
- 如果传递的是一个对象或者时数组时也可以直接解构
- 在函数中如果结构的是对象需要使用`{}`包裹起来,否则只有第一个会获取到实参,其余都是`undefined`
- 如果不进行包裹就不是结构赋值,而是单纯的传递参数
- 数组需要使用`[]`进行包裹

```javascript
function test(...arr){
  console.log(arr);
  /**
   *  获取到传递的全部实参,
   *  同时arr是一个真数组,可以使用数组的所有方法
   */
}
test(10,20,30)

function test({name,aeg,sex}){
  console.log(name,age,sex)
  /**
   * name:'平野绫',
   * age:20,
   * sex:'女'
   */
}
test({name:'平野绫',age:20,sex:'女'});

function test([a,b,...c]){
  console.log(a,b,c)
  /**
   *  a = 1,
   *  b = 2,
   *  c = [3,4,5,6]
   */
}
test([1,2,3,4,5,6]);
```

### 细节

复合赋值运算符

| 语法  | 含义  |
|:-----|:------|
| +=   | 加等于 |
| -=   | 减等于 |
| \*=  | 乘等于 |
| /=   | 除等于 |
| %=   | 余等于 |
| \*\* | 幂等于 |

```javascript
var a = 3;
a += 4;
/**
* a = 7;
* 等价于:
* a = a + 4
* 其余符合运算符语法相同
*/
```

- 运算符拥有优先级,即使是相同的运算符法使用的位置不同,优先级和运算规则也会不一样
- 当不清楚运算符的优先级时,可以使用`()`将其包裹起来,因为它的优先级是最高的

数字越大优先级越高

![nvOVN4.png](https://s2.ax1x.com/2019/09/21/nvOVN4.png)

![nvOkHU.png](https://s2.ax1x.com/2019/09/21/nvOkHU.png)

![nvOiuV.png](https://s2.ax1x.com/2019/09/21/nvOiuV.png)


## 控制语句

### 判断语句

> 根据判断条件来执行不同的语句,

```javascript
if(num > 100){
  //=>条件为true执行
} else if(num < 100){
  //=>如果上述条件为false,继续判断
  //=>如果上述条件为true,则会立即停止整个判断语句
} else {
  //=>所有判断条件都不通过时,直接执行
}
```

> 可以值书写一个`if`,而不书写其他的判断语句,这样只会在判断条件为`true`的时候执行,其余情况都不执行

```javascript
if(num>=10){
  //=>num大于等于10的进入判断体
}
//=>不书写其他判断语句,只在条件为true时执行
```

**不要直接将引用类型作为判断条件,因为引用类型转换为布尔值永远是`true`**

```javascript
let obj = {a:false};

if(obj){
  //=>判断条件如果是一个引用类型的话,那么条件永远为真
}

if(obj.a){
  //=>使用对象的属性是可取的,只有当对象的属性转换为布尔值是true时才会进入判断体
}
```

> `switch case`是js中的另一个判断语句,

- 每一个`case`子语句后面都要书写`break`关键字,如果没有则会从匹配项开始将后面的语句全部执行,无论条件是否匹配
- `case`子语句在匹配时是基于`===`进行比较,不会对比较的值进行类型转换

```javascript
if(num===10){
} else if( num === 5){
} else {
}

//=>改写成switch语句

switch(num){
  case 10:
    //=>匹配时执行
    break;
  case 5:
    //=>匹配时执行
    break;
  default:
    //=>没有匹配项时执行
}
```

### 循环语句

> 根据设定的条件重复的执行一些语句,如果条件设置不当则会造成死循环(无限循环),造成浏览器崩溃

循环语句应该拥有`初始表达式`,`循环条件`,`更新表达式`这三个要素,每一次的循环都会对`循环条件`和`更新表达式`进行执行,只有当`循环条件`返回`true`时才会循环

执行步骤

1. 初始化表达式,表达式可以是一个变量声明,也可以是一个复杂的表达式,初始表达式只会执行一次
2. 判断循环条件,为`true`时继续执行其他步骤,为`false`时直接终止循环
3. 执行循环语句,遇到`continue`关键字会直接执行更新表达式,遇到`break`关键字终止循环
4. 执行更新表达式,
5. 重复执行步骤2~4

```javascript
for(var i = 0;i < 10; i++){
  /**
   * var i = 0;  初始表达式
   * i < 10;     循环条件
   * i++;        更新表达式
   */
}

```

> `while`循环语句同样需要三个条件,只要条件为`true`就会一直执行

```javascript
let num =4;
//=>初始表达式
while(num<4){
//=>判断条件
num--;
/**
* 更新表达式
* while循环语句很容易忘记书写更新表达式
* 如果没有书写则会造成死循环
*/
}
```

> `do/while`循环语句第一次执行并不会判断循环条件,只有在第一次循环执行完毕之后,在进行判断,根据判断条件的返回值决定是否继续循环

```javascript
let num = 5;
//=>初始表达式
do{
  num++;
  //=>更新表达式
}while(num<5);
//=>循环条件
```

> `while`根据判断条件可能一次也不会执行,而`do/while`无论判断条件是否为`true`,都会执行一次


> `for/in`循环只要是对对象进行遍历,虽说也可以遍历数组,但是由于其查找机制是无需查找,因此遍历出的数组元素可能会于原数组的顺序不同,可以使用普通的`for`循环或者ES6中新增加的`forEach`方法进行遍历

- 遍历对象时也会查找出原型中的属性或者方法
- 遍历数组时是无序遍历,有时候遍历出的元素顺序并不准确

```javascript
let obj = {name:'平野绫',age:20,};
for(let key in obj){
  console.log(key);
  //=>输出对象的每一个属性名
  console.log(obj[key]);
  //=>输出对象的每一个属性值
  if(obj.hasOwnProperty(key)){
    /**
     * for in 在遍历属性的时候也会遍历出原型中的属性
     * 使用hasOwnProperty可以过滤掉原型中的属性
     */
  }
}
```

> `for/of`是ES6中新增加的一种遍历方式,只要是当前的数据结构上部署了`Symbol.iterator`就可以进行遍历,`for/of`的本质就是调用数据结构上的`Symbol.iterator`函数产生的遍历器进行遍历

### 关键字

1 `break`关键字会直接终止循环,无论判断条件是否满足都会终止 2
`continue`关键字会跳过当次的循环,会直接执行更新表达式,然后在根据判断条件的返回值决定是否继续进行下一次的循环

```javascript
for(var i = 0; i < 10;i++){
  if(i%2===0){
    continue;
    //=>i为偶数的时候跳过档次循环
  }else if(i === 8){
    break;
    //=>i===5的时候终止循环语句,不会在进行循环
  }
  console.log(i);
  //=>输出8以下的所有奇数
}
```

## 标准库

### Array

#### push

> 作用:向数组的末尾添加新的元素 参数:追加的内容(一个或多个任意数据类型)
> 返回值:新增后数组的长度 原有数组改变

```javascript
let arr = [10,20,30];
arr.push(10,null);
//=>追加两个不同类型的元素,返回数组的长度
```

#### pop

> 作用:删除数组的最后一项 参数:无 返回值:被删除的数组元素 原有数组改变

```javascript
var arr = [10,20,30];
arr.pop();
//=>无参数,返回30
```

#### unshift

> 作用:在数组最开始的位置添加新的数组 参数:要添加的内容(一到多个任意类型)
> 返回:新增后数组的长度 原有数组改变

```javascript
let arr = [10,20,30];
arr.unshift('20',undefined);
//=>返回数组长度
```

#### shift

> 作用:删除数组最开始的一项 参数:无 返回值:被删除的数组项 原有数组改变

```javascript
let arr = [10,20,30];
arr.shift();
//=>返回10,所有的数组项的索引值都会-1
```

#### splice

> 作用:删除,添加,修改指定位置的数组项 参数:起始位置,删除数量(可选),添加项(可选)
> 返回值:删除的数组先形成的数组,没删除返回空数组 原有数组改变

删除

```javascript
let arr = [10,20,30,40,50];
arr.splice(1,3);
/**
* 返回:[20,30,40]
* 如果只传递起始位置或者结束位置大于数组的总长度
* 则会从数组的起始位置删除至数组的最后一项
*/

arr.splice(arr.length-1);
//=>删除数组的最后一项

arr.splice(4);
//=>如果其实位置和数组的length属性一直,将不会删除任何数据

arr.splice(0,'q');
//=>如果结束位置参数不合法也不会报错,但是不会对数组进行任何操作,同时返回一个空数组
```

新增

```javascript
let arr = [10,20,30];
arr.splice(arr.length,0,40);
//=>项数组的最后以为添加新的元素,第二个参数不能省略,否则添加项会被误认为是结束位置

arr.splice(0,0,1,2,3);
//=>向数组的起始位置添加新的数组项

arr.splice(2,0,21,22,23);
/**
* 根据起始位置的不同,向数组的任意位置添加新的数组项
* 在索引为2的数组项前面添加新的数组项
*/
```

修改

```javascript
let arr = [10,20,30,40];
arr.splice(2,3,60,80);
/**
* 通过删除指定位置的数组项
* 然后将新增的数组项进行添加
*/
```

#### reverse

> 作用:将数组的顺序进行颠倒 参数:无 返回值:颠倒后的数组 原有数组改变

```javascript
let arr = [10,20,30,40];
arr.reverse();
//=>[40,30,20,10]

arr.reverse().reverse();
//=>可以连续调用两次,颠倒两次的数组则不会发生变化
```

#### sort

> 作用:数组排序 参数:无/回调函数 返回值:排序后的新数组 原有数组改变

- 如果不传递参数,`sort`的默认排序方式是根据`Unicode`编码进行排序,(只能处理10以内的数组项,不包括10)
- 可以传递一个回调函数来只当排序的规则

```javascript
let arr = [5,2,8,6,4,3,1,9,7];
arr.sort();
//=>[1,2,3,4,5,6,7,8,9]可以正确的排序

let arr = [5,2,8,6,4,3,1,9,7,10,11,12,13,14];
arr.sort();
//=>[1,10,11,12,13,14,2,3,4,5,6,7,8,9]处理结果不正确
```

- 回调函数拥有两个参数(通常会设置为a和b)
- `a`代表当前的数组项,`b`代表下一个数组项
- 自定的排序方式根据回调函数的返回值进行排列
- 返回大于或等于`1`的数字则a会被排列在b之前
- 返回`0`则a和b的位置不变
- 返回小于`1`的数字则b会排列在a之前

```javascript
let arr = [21,3,25,15,65,78,85];
arr.sort(function(a,b){
  return a-b;
  /**
   * 升序排列数组,从小到大
   * a-b如果是大于或等于1的话
   * 说明a比b大,则a排列在b之前,位置不做交换
   * 如果等于0,说明两个大小一样,则不交换位置
   * 如果小于1的话则说明a比b小,
   * 则b排列在a之前
   */
  
  return b - a;
  //=>降序排列,从大到小
})
```

> 如果回调函数返回一个固定值,则不同的浏览器处理方式都是不同的


```javascript
let arr = [2,15,48,8,5,156,4];
arr.sort((a,b)=>{
  return Math.floor(Math.random()*5);
  /**
   * 在火狐浏览器中可以随机排列数组,
   * 谷歌浏览器中数组位置则是不变
   * 使用`webkit`内核的浏览器都不是改变
   */
})
```

#### slice

> 作用:从规定的数据区域进行数组项的浅拷贝
> 参数:起始位置(可选),结束位置(可选),没有参数则浅拷贝全部数组项
> 返回值:浅拷贝的数据形成的数组 原有数组不变

```javascript
let arr = [10,20,30,40,50];
arr.slice(2,4)
//=>[30,40],不会浅拷贝结束位置上的数组项

arr.slice();
//=>浅拷贝整个数组,新旧数组并不相等

arr.slice(2);
//=>只书写一个参数默认是起始位置,会一直浅拷贝至数组的最后一项

arr.slice(10);
//=>起始位置超过最大索引值,返回一个空数组

arr.slice(-4,-2);
//=>支持负数,数组的length + 参数 = 操作的位置
```

#### concat

> 作用:将多个数组(或值)进行拼接 参数:需要拼接的数组或值 返回值:拼接后的数组
> 原有数组不变

> 拼接后的数组位置根据拼接时的顺序决定

```javascript
let arr = [10,20],
    arr2 = [30,40];
arr.concat(arr2);
//=>返回拼接后的数组

arr.concat(arr2,50,60);
//=>同时拼接数组和值
```

#### toString

> 作用:将数组转换为字符串 参数:无 返回值:转换后的字符串 原有数组不变

```javascript
let arr = [10,20,30,40,50];
arr.toString();
//=>返回转换后的数组,每一个数组元素之间也会使用,隔开
```

#### join

> 作用:将数组转换为字符串,并且指定数组项之间的连接符 参数:指定的连接符
> 返回值:转换后的字符串 原有数组不变

```javascript
let arr = [10,20,30,40];
arr.join('+');
//=>将数组转换为字符串,并且以+隔开每一个数组项

arr.join('');
//=>转换后的数组项之间不使用任何符号隔开
```

#### index

> 作用:检测当前的数组行在数组中第一次出现的索引
> 参数:需要检测的数组项,起始的查找位置(可选) 返回值:出现位置的索引值或-1
> 原有数组不变

```javascript
let arr = [10,20,30,50,60];
arr.indexOf(30)
//=>返回第一次出现的位置,存在相同的数组项时也只会返回第一次出现的索引值

arr.indexOf(100);
//=>没有对应的数组项时返回 -1

arr.indexOf(30,10);
/**
* 设置起始的查找位置,
* 查找值在起始位置之前出现,不在起始位置后出现
* 仍然返回 -1
* 支持使用负数
* 负数表示从数组末尾的第几个数组项开始查找
* 如果负数的绝对值大于数组长度则整个数组都会被查找
*/

if(arr.indexOf(30) > -1){
  //=>判断一个数组中是否存在某一个项
}
```

#### lastIndexOf

> 作用:检测数组项最数组中最后一次出现的位置,从数组末尾优先查找
> 参数:查找的数组,起始位置(可选) 返回值:索引值或-1 原有数组不变 原有数组不变

```javascript
let arr = [10,20,30,40,50];
arr.lastIndexOf(30);
//=>返回对应的索引值

arr.lastIndexOf(100);
//=>不存在返会-1

arr.lastIndexOf(30,2);
/**
* 从索引值为2的位置开始向左查找
* 设置查找的起始位置,从数组末尾向前查找,默认的起始位置时arr.length-1
* 如果起始位置大于或者等于数组的总长度,则整个数组都会被查找
* 
* 支持负数  > 数组的length + 负数 = 起始位置
* 如果负数的绝对值大于数组长度则不会查找,直接返回 -1
*/
```

#### Array.from

> 作用:将类数组转换为真数组 参数:需要转换的类数组 返回值:转换后的真数组 原有数组不变

`Array.from`是一个静态方法,无法使用数组实例调用,只能原型使用,

```javascript
function test(){
  Array.from(arguments);
  //=>将arguments转换为真数组
}

let el = document.getElementsByClassName('ceshi');
//=>将元素集合转换为真数组
```

#### forEach

> 作用:对数组的每一个元素都执行一次回调函数, 参数:回调函数 返回值:undefined
> 原有数组不变

```javascript
let arr = [10,20,30,40,50,60];
arr.forEach(function(currentValue,index,arr,thisArr){
  /**
   * currentValue  == 当前的数组项
   * index  === 数组项的索引
   * arr  === 操作的数组
   * thisArr  === 函数中的this指向
   * 
   * 通常用来遍历数组
   */
})
```

`forEach`会在遍历的过程中产生闭包

```javascript
let nodeList = document.getElementsByClassName('ceshi');
//=>根据class类名获取页面中的标签
Array.from(nodelist).forEach(function(el,index){
  //=>将获取到的类数组转换为数组
  el.onclick=function(){
    //=>为每一个标签设置点击事件
    console.log(index);
    //=>每一次点击输出对应标签的索引值
  }
})

//=>使用普通的for循环绑定会无法获取到正确的值,因为没有产生闭包
for(var i =0;i<nodeList.length;i++){
  nodeList[i].onclick=function(){
    console.log(i)
    /**
     * 可以正确的绑定点击时间,但是无法获取到正确的索引值
     * 因为在点击时间出发的时候for循环已经运行结束,
     * i的值就已经固定了
     * 
     * 在普通for循环中使用let申请变量也会产生闭包
     * 就可以获取到正确的值
     */
  }
}
```

#### filter

> 作用:筛选数组中的每一项 参数:回调函数 返回值:符合规则的数组项形成的数组
> 原有数组不变

```javascript
let arr = [10,20,30,40,50];
arr.filter(function(currentValue,idnex,arr,thisArr){
  /**
   * currentValue  === 当前的数组项
   * index   === 当前数组项的索引
   * arr   === 操作的数组
   * thisArr  === 回调函数中this的指向
   */
  
  return currentValue % 2 != 0;
  //=>获取数组中的奇数
})
```

### String

#### charAt